#!/usr/bin/perl -Tw

use Config::General;
use Data::Dumper;
use DBI;
use File::Path qw(mkpath);
use File::Slurp qw(write_file);
use Log::Log4perl qw(:easy :no_extra_logdie_message);
use LWP::UserAgent;
use XML::FeedPP;
use MP3::Info qw(get_mp3info);
use Ogg::Vorbis::Header;
use File::Temp qw(tempfile);

use feature 'state';
use feature 'switch';
use strict;

sub DBH();        # defined by setup
sub CONFIG();     # defined by setup
sub COMMAND();    # defined by register_commands
sub USER_AGENT(); # below

$SIG{__DIE__} = sub {
	if ($^S) {
		# We're in an eval {} and don't want log
		# this message but catch it later
		return;
	}
	$Log::Log4perl::caller_depth++;
	LOGDIE @_;
};

setup();
register_commands();
go();

# functions only below
exit 0;

sub go {
	unless (@ARGV) {
		FATAL "You need to specify a command. Try $0 help";
		exit 1;
	}

	my $cmd = lc(shift @ARGV);
	unless (exists COMMAND->{$cmd}) {
		FATAL "Unknown command '$cmd'. Try $0 help";
		exit 1;
	}

	TRACE("Dispatching command '$cmd'");
	COMMAND->{$cmd}(@ARGV);

	TRACE("Command done; committing");
	DBH->commit();
}

sub register_commands {
	*COMMAND = sub() {
		{
			add       => \&add_podcast,
			new       => \&add_podcast,
			subscribe => \&add_podcast,

			fetch     => \&fetch,
			download  => \&download,
			stopwatch => \&stopwatch,

			help => \&help,
		};
	};
	TRACE("Commands registered");
}

sub add_podcast {
	my ($name, $url) = @_;

	DBH->do(<<QUERY, {}, $name, $url);
INSERT INTO feeds(feed_name, feed_url) VALUES(?, ?)
QUERY
}

sub fetch {
	TRACE("Finding enabled feeds in db");
	my $sth = DBH->prepare(<<QUERY);
SELECT
    feed_no, feed_name, feed_url
  FROM feeds
  WHERE feed_enabled = 1
  ORDER BY feed_no
QUERY
	$sth->execute;

	my $check = DBH->prepare(<<QUERY);
SELECT 1 FROM enclosures
  WHERE enclosure_url = ?
QUERY

	my $ins = DBH->prepare(<<QUERY);
INSERT INTO enclosures (
  feed_no, enclosure_url, enclosure_when
) VALUES (?, ?, ?)
QUERY

	while (my ($feed_no, $feed_name, $feed_url) = $sth->fetchrow_array) {
		TRACE("Fetching $feed_name (feed#$feed_no)");
		my $resp = USER_AGENT->get($feed_url);
		unless ($resp->is_success) {
			ERROR("Downloading of $feed_name from $feed_url failed:");
			ERROR($resp->status_line);

			next; # ignore this feed
		}

		my $content_type = $resp->content_type;
		TRACE("Content-Type: $content_type");
		$content_type =~ m#^(application/((rss|atom|rdf)\+)?xml)|(text/xml)$ #x
			or WARN("Unexpected MIME type $content_type; bad things may happen");

		TRACE("Handing over to the feed parser");
		my $feed = XML::FeedPP->new($resp->decoded_content);
		unless ($feed) {
			ERROR("Feed parser failed.");
			next;
		}

		foreach my $item ($feed->get_item) {
			my $enc_url = $item->get('enclosure@url');
			unless ($enc_url) {
				DEBUG("Item ".$item->title." has no enclosure");
				next;
			}

			my $enc_type = $item->get('enclosure@type');
			unless ('' eq $enc_type || $enc_type =~ m#^audio/(ogg|mpeg)$ #x) {
				INFO("Skipping uknown enclosure type $enc_type");
				next;
			}

			$check->execute($enc_url);

			if ($check->fetchrow_arrayref) {
				TRACE("Skipping already-in-db $enc_url");
				next;
			}
			$check->finish; # just in case

			DEBUG("Adding $enc_url from ".$item->title);
			$ins->execute($feed_no, $enc_url, $item->get_pubDate_epoch);
		}
	}
}

sub download {
	# We sort by feed number in hopes of maximizing use of persistent
	# connections (HTTP Keepalive). Sort by the date to give the user a
	# predictable order.
	TRACE("Finding undownloaded media");
	my $sth = DBH->prepare(<<QUERY);
SELECT enclosure_no, enclosure_url
  FROM enclosures
  WHERE enclosure_file IS NULL
  ORDER BY feed_no, enclosure_when
QUERY
	$sth->execute;

	my $upd = DBH->prepare(<<QUERY);
UPDATE enclosures
  SET enclosure_file = ?
  WHERE enclosure_no = ?
QUERY

	my $dir = CONFIG->{storage}{pendingmedia};

	while (my ($enc_no, $enc_url) = $sth->fetchrow_array) {
		INFO("Downloading $enc_url");
		my (undef, $tmp) = tempfile('download.XXXXXX', DIR => notaint($dir));
		my $resp = USER_AGENT->get( $enc_url, ':content_file' => $tmp);
		unless ($resp->is_success) {
			ERROR("Downloading $enc_url failed:");
			ERROR($resp->status_line);
			unlink($tmp);
			next;
		}

		my $name = $resp->filename;
		TRACE("Server's name: $name");

		# Sanitize
		$name =~ tr/-_.a-z0-9//cd;

		# Figure filename suffix
		my $ctype = $resp->content_type;
		my $suffix;
		given ($ctype) {
			when ('audio/mpeg') { $suffix = 'mp3' }
			when ('audio/ogg')  { $suffix = 'ogg' }
			default             { $suffix = 'wtf' }
		}
		TRACE("Content-Type: $ctype; suffix: $suffix");

		$name =~ /\.$suffix$/
			or $name .= ".$suffix";

		# Prefix enclosure number, guaranteeing uniqueness.
		$name = sprintf("%04i_%s", $enc_no, $name);

		# Rename
		TRACE("Renaming to: $name");
		rename($tmp, notaint("$dir/$name"));

		$upd->execute($name, $enc_no);
	}
}

sub stopwatch {
	my $sth = DBH->prepare(<<QUERY);
SELECT enclosure_no, enclosure_file
  FROM enclosures
  WHERE
    enclosure_file IS NOT NULL
    AND enclosure_time IS NULL
QUERY

	my $upd = DBH->prepare(<<QUERY);
UPDATE enclosures
  SET enclosure_time = ?
  WHERE enclosure_no = ?
QUERY

	TRACE("Finding media without length in db");
	$sth->execute;

	my $dir = CONFIG->{storage}{pendingmedia};
	while (my ($enc_no, $enc_file) = $sth->fetchrow_array) {
		my $len;
		unless ($enc_file =~ /\.(.{3})$/) {
			ERROR("Could not find suffix in $enc_file");
			ERROR("This shouldn't happen, as wel always set a suffix. WTF.");
			next;
		}

		my $file = notaint("$dir/$enc_file");
		given ($1) {
			when ('mp3') {
				my $inf = get_mp3info($file);
				if ($inf) {
					$len = $inf->{SECS};
				} else {
					WARN("Could not get length of $file");
				}
			}
			when ('ogg') {
				WARN("Ogg length code is untested. Please send reports.");
				my $ogg = Ogg::Vorbis::Header->new($file);
				if ($ogg) {
					$len = $ogg->info('length');
				} else {
					WARN("Ogg parser doesn't think $file is ogg");
				}
			}
			default {
				ERROR("Don't know how to get length of $1 files");
			}
		}

		defined $len && 0 == $len
			and WARN("Got length of 0 for $file; probably wrong!");

		TRACE("$enc_file: " . (defined $len ? $len : 'undef'));
		$upd->execute($len, $enc_no);
	}
}

sub help {
	print STDERR <<HELP;
Usage: $0 command arguments

Commands are:

   subscribe, new, add Name URL
      Subscribe to a new podcast named Name with feed at URL. URL
      should be the RSS or Atom feed. Name is anything you want, but
      must be unique for all your subscribed podcasts. Remember to quote
      Name and URL for your shell.

   fetch
      Grabs the subscribed RSS feeds and adds all the enclosures to the
      database. Does not actually download the enclosures.

   download
      Downloads enclosures that are in the database (from fetch) but not
      yet downloaded.

   stopwatch
      Calculates how long each downloaded podcast is, and stores this
      information in the database.
   
   help
      Duh.
HELP
}

sub notaint {
	$_[0] =~ /^(.+)$/s;
	$1;
}

sub setup {
	my $confdir = notaint("$ENV{HOME}/.podist");

	-d $confdir
		or mkdir $confdir
		or die "Could not mkdir $confdir: $!";

	# read config and install sub
	my $config = setup_config($confdir);
	*CONFIG = sub() { $config };

	init_logging();

	if (CONFIG->{notyetconfigured}) {
		FATAL(<<ERR);
Podist has not been configured. Please review this configuration file
and set NotYetConfigured to false:
    $confdir/podist.conf
ERR
		exit 1;
	}

	# Setup our output directories.
	setup_dirs();

	# setup the DB and install DBH subroutine
	my $dbh = setup_db();
	*DBH = sub() { $dbh };
}

sub setup_dirs {

	for my $d (
		@{CONFIG->{storage}}{
			qw(pendingmedia playlistedmedia
				playlists)
		})
	{
		-d $d
			or mkpath(notaint($d))
			or LOGDIE("Could not mkpath($d): $!");
	}
}

sub init_logging {
	if (CONFIG->{logging}{simple}) {
		my $level = uc(CONFIG->{logging}{level});
		Log::Log4perl->init(\<<L4P);
log4perl.category = $level, Screen
log4perl.appender.Screen = Log::Log4perl::Appender::ScreenColoredLevels
log4perl.appender.Screen.layout = Log::Log4perl::Layout::PatternLayout::Multiline
log4perl.appender.Screen.layout.ConversionPattern = [%r] %m%n
L4P
	} else {
		Log::Log4perl::init(CONFIG->{logging}{config});
	}
	TRACE("Log4perl configured and hopefully ready.");
}

sub setup_config {
	my ($confdir) = @_;
	my $conffile = "$confdir/podist.conf";

	my $default_config = <<CONF;
# Once you've reviewed this file, change this to false.
NotYetConfigured true
DataDir $confdir # e.g., \$HOME/.podist

<storage>
	PendingMedia    \$HOME/Podist/media-pending
	PlaylistedMedia \$HOME/Podist/media-listed
	Playlists       \$HOME/Podist/playlists
</storage>

<database>
	DSN dbi:SQLite:dbname=\$DataDir/podist.db
	Username   # fill in if DB requires
	Password   # fill in if DB requires
</database>

<logging>
	Simple true
	Level info   # fatal | error | warn | info | debug | trace

	### Alternatively, for more control,
	# Simple false
	# Config \$DataDir/log4perl.conf
</logging>
CONF

	-e $conffile
		or write_file($conffile, \$default_config);

	# Don't repeat yourself.
	#
	# Unfortunately, we need the string representation of the config (so
	# we can have comments in it), hopefully this isn't too slow...
	my $cg_def = new Config::General(
		-String               => $default_config,
		-AllowMultiOptions    => 0,
		-LowerCaseNames       => 1,
		-UseApacheInclude     => 1,
		-IncludeRelative      => 1,
		-IncludeDirectories   => 1,
		-IncludeGlob          => 1,
		-IncludeAgain         => 1,
		-MergeDuplicateBlocks => 1,
		-AutoLaunder          => 1,
		-AutoTrue             => 1,
		-InterPolateVars      => 1,
		-InterPolateEnv       => 1,
		-StrictVars           => 1,
		-SplitPolicy          => 'whitespace',
	);
	my %defs = $cg_def->getall;

	# Yes, in the first-use case, this will be the exact same as the
	# defaults, but oh well.
	my $cg_conf = new Config::General(
		-ConfigFile            => $conffile,
		-AllowMultiOptions     => 0,
		-LowerCaseNames        => 1,
		-UseApacheInclude      => 1,
		-IncludeRelative       => 1,
		-IncludeDirectories    => 1,
		-IncludeGlob           => 1,
		-IncludeAgain          => 1,
		-MergeDuplicateBlocks  => 1,
		-MergeDuplicateOptions => 1,
		-AutoLaunder           => 1,
		-AutoTrue              => 1,
		-InterPolateVars       => 1,
		-InterPolateEnv        => 1,
		-StrictVars            => 1,
		-SplitPolicy           => 'whitespace',
		-DefaultConfig         => \%defs,
	);

	return {$cg_conf->getall};
}

use constant DB_VERSION => 1;

sub setup_db {
	TRACE("Connecting to the database.");
	my $dbh = DBI->connect(
		CONFIG->{database}{dsn},
		CONFIG->{database}{username},
		CONFIG->{database}{password},
		{
			AutoCommit       => 0,
			RaiseError       => 1,
			PrintError       => 0,
			FetchHashKeyName => 'NAME_lc',
		});

	my ($vers) = $dbh->selectrow_array('PRAGMA user_version');
	$vers > DB_VERSION
		and die "Database is from newer version of this program";

	if (0 == $vers) {
		INFO("Creating Podist database.");
		# need to create db.
		$dbh->do(<<SQL);
CREATE TABLE feeds (
  feed_no        INTEGER   NOT NULL PRIMARY KEY,
  feed_url       TEXT      NOT NULL UNIQUE,
  feed_name      TEXT      NOT NULL UNIQUE,
  feed_enabled   INTEGER   NOT NULL DEFAULT 1,
  CONSTRAINT enabled_is_bool CHECK (feed_enabled IN (0,1))
)
SQL
		$dbh->do(<<SQL);
CREATE TABLE playlists (
  playlist_no    INTEGER   NOT NULL PRIMARY KEY,
  playlist_ctime INTEGER   NOT NULL
)
SQL
		$dbh->do(<<SQL);
CREATE TABLE enclosures (
  enclosure_no     INTEGER   NOT NULL PRIMARY KEY,
  feed_no          INTEGER   NOT NULL REFERENCES feeds,
  enclosure_url    TEXT      NOT NULL UNIQUE,
  enclosure_file   TEXT      NULL UNIQUE,
  enclosure_when   INTEGER   NOT NULL, -- unix timestamp
  enclosure_time   REAL      NULL, -- length in seconds
  playlist_no      INTEGER   NULL REFERENCES playlists,
  playlist_so      INTEGER   NULL,
  UNIQUE(playlist_no, playlist_so)
)
SQL
		$dbh->selectrow_array('PRAGMA user_version = 1');
		$dbh->commit;
		TRACE("Database creation done.");
	} elsif (1 == $vers) {
		DEBUG("Version 1 database found");
		# current, do nothing.
	} else {
		LOGDIE "BUG: Unknown (but not future!) database version";
	}

	return $dbh;
}

sub USER_AGENT() {
	state $agent;
	unless ($agent) {
		$agent = LWP::UserAgent->new(
			agent => 'Podist/0.1 ', # space at end: append _agent
			env_proxy => 1,
			keep_alive => 4, # Some podcasts love redirects
			cookie_jar => { }, # temp only
		);

		$agent->default_header(
			Accept => 'application/rss+xml, application/atom+xml, audio/ogg, audio/mpeg, application/rdf+xml;q=0.9, application/xml;q=0.8, text/xml;q=0.8, application/ogg;q=0.8, audio/*;q=0.7, */*;q=0.1'
		);
	}

	return $agent;
}
