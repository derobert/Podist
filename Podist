#!/usr/bin/perl -Tw

use Config::General;
use Data::Dumper;
use DBI;
use Digest;
use File::Find qw(find);
use File::Path qw(mkpath);
use File::Slurp qw(write_file);
use File::Temp qw(tempfile);
use IPC::Run3;
use List::MoreUtils qw(pairwise);
use Log::Log4perl qw(:easy :no_extra_logdie_message);
use LWP::UserAgent;
use MP3::Info qw(get_mp3info);
use Ogg::Vorbis::Header;
use POSIX qw(strftime);
use Text::ASCIITable;
use XML::FeedPP;
use Carp qw(longmess);

use feature 'state';
use feature 'switch';
use strict;

sub DBH();        # defined by setup
sub CONFIG();     # defined by setup
sub COMMAND();    # defined by register_commands
sub USER_AGENT(); # below

my %SUFFIX_MAP = (
	'audio/mpeg'        => 'mp3',
	'audio/x-mpeg'      => 'mp3',    # retards
	'audio/x-mp3'       => 'mp3',    # morons
	'x-audio/mp3'       => 'mp3',    # idiots
	'audio/ogg'         => 'ogg',
	'audio/x-ogg'       => 'ogg',
	'application/ogg'   => 'ogg',
	'application/x-ogg' => 'ogg',
);

setup();

# Don't do this until after setup, because we need log4perl ready first!
$SIG{__DIE__} = sub {
	if ($^S) {
		# We're in an eval {} and don't want log
		# this message but catch it later
		return;
	}
	$Log::Log4perl::caller_depth++;
	LOGDIE longmess(@_);
};

register_commands();
go();

# functions only below
exit 0;

sub go {
	unless (@ARGV) {
		FATAL "You need to specify a command. Try $0 help";
		exit 1;
	}

	my $cmd = lc(shift @ARGV);
	unless (exists COMMAND->{$cmd}) {
		FATAL "Unknown command '$cmd'. Try $0 help";
		exit 1;
	}

	TRACE("Dispatching command '$cmd'");
	COMMAND->{$cmd}(@ARGV);

	TRACE("Command done; committing");
	DBH->commit();
}

sub register_commands {
	*COMMAND = sub() {
		{
			add       => \&add_podcast,
			new       => \&add_podcast,
			subscribe => \&add_podcast,

			catch     => \&catch,
			fetch     => \&fetch,
			download  => \&download,
			stopwatch => \&stopwatch,
			hash      => \&hasherize,
			hasherize => \&hasherize,
			originalize => \&originalize,

			playlist  => \&playlist,
			all_playlists => \&all_playlists,

			status    => \&status,

			help => \&help,
		};
	};
	TRACE("Commands registered");
}

sub add_podcast {
	my ($name, $url) = @_;

	DBH->do(<<QUERY, {}, $name, $url);
INSERT INTO feeds(feed_name, feed_url) VALUES(?, ?)
QUERY
}

sub catch {
	fetch();
	download();
	stopwatch();
	hasherize();
	originalize();
}

sub fetch {
	TRACE("Finding enabled feeds in db");
	my $sth = DBH->prepare(<<QUERY);
SELECT
    feed_no, feed_name, feed_url, feed_all_audio
  FROM feeds
  WHERE feed_enabled = 1
  ORDER BY feed_no
QUERY
	$sth->execute;

	my $check = DBH->prepare(<<QUERY);
SELECT 1 FROM enclosures
  WHERE enclosure_url = ?
QUERY

	my $ins = DBH->prepare(<<QUERY);
INSERT INTO enclosures (
  feed_no, enclosure_url, enclosure_when
) VALUES (?, ?, ?)
QUERY

	while (my ($feed_no, $feed_name, $feed_url, $all_audio)
		= $sth->fetchrow_array)
	{
		INFO("Fetching $feed_name (feed#$feed_no)");
		my $resp = USER_AGENT->get($feed_url);
		unless ($resp->is_success) {
			ERROR("Downloading of $feed_name from $feed_url failed:");
			ERROR($resp->status_line);

			next; # ignore this feed
		}

		my $content_type = $resp->content_type;
		TRACE("Content-Type: $content_type");
		$content_type =~ m#^(application/((rss|atom|rdf)\+)?xml)|(text/xml)$ #x
			or WARN("Unexpected MIME type $content_type; bad things may happen");

		TRACE("Handing over to the feed parser");
		my $feed = eval {
			XML::FeedPP->new($resp->decoded_content, type => 'string');
		};
		if ($@) {
			ERROR("Feed parse exploded: $@");
			next;
		}
		unless ($feed) {
			ERROR("Feed parser failed.");
			next;
		}

		my ($date_last1, $date_last2);
		foreach my $item ($feed->get_item) {
			my $enc_url = $item->get('enclosure@url');
			(my $item_title = $item->title) =~ y/\x0a\x0d/ /;
			$item_title =~ s/^\s+//;
			$item_title =~ s/\s+$//;
			unless ($enc_url) {
				my $msg = "Item $item_title has no enclosure";
				$all_audio ? INFO($msg) : TRACE($msg);
				next;
			}

			my $enc_type = $item->get('enclosure@type');
			unless ('' eq $enc_type || $enc_type =~ m#^(audio|x-audio|application)/(ogg|x-ogg|mpeg|x-mpeg|x-mp3|mp3)$ #x) {
				my $msg = "Skipping $item_title (uknown enclosure type $enc_type)";
				$all_audio ? WARN($msg) : TRACE($msg);
				next;
			}

			$check->execute($enc_url);

			if ($check->fetchrow_arrayref) {
				TRACE("Skipping already-in-db $enc_url");
				next;
			}
			$check->finish; # just in case

			DEBUG("Adding $enc_url from ".$item->title);
			my $date = $item->get_pubDate_epoch;
			if (!$date) {
				ERROR("get_pubDate_epoch failed");
				if (defined $date_last2) {
					if ($date_last2 > $date_last1) {
						# podcast is most-recent first
						WARN("Assuming one second BEFORE previous");
						$date = $date_last1 - 1;
					} elsif ($date_last2 < $date_last1) {
						# podcast is least-recent first
						WARN("Assuming one second AFTER previous");
						$date = $date_last1 + 1;
					} else {
						WARN("Assuming same date as previous two!");
						$date = $date_last1;
					}
				} elsif (defined $date_last1) {
					# randomly guess podcast is most-recent first; a lot
					# seem to be.
					WARN("Guessing most-recent first");
					WARN("Guessing one second BEFORE previous");
					$date = $date_last1 - 1;
				} else {
					WARN("Is first item; no fâ€”ing clue what date to use");
					WARN("Using current time!");
					$date = time;
				}
				DEBUG("The time is now "
						. strftime("%F %H:%M:%S %Z", localtime($date))
						. ".\nDo you know where your podcasts are?");
			}
			$ins->execute($feed_no, $enc_url, $date);
			$date_last2 = $date_last1;
			$date_last1 = $date;
		}
	}
}

sub download {
	# We sort by feed number in hopes of maximizing use of persistent
	# connections (HTTP Keepalive). Sort by the date to give the user a
	# predictable order.
	TRACE("Finding undownloaded media");
	my $sth = DBH->prepare(<<QUERY);
SELECT enclosure_no, enclosure_url
  FROM enclosures
  WHERE enclosure_file IS NULL AND enclosure_use = 1
  ORDER BY feed_no, enclosure_when
QUERY
	$sth->execute;

	my $upd = DBH->prepare(<<QUERY);
UPDATE enclosures
  SET enclosure_file = ?
  WHERE enclosure_no = ?
QUERY

	my $dir = CONFIG->{storage}{pendingmedia};

	while (my ($enc_no, $enc_url) = $sth->fetchrow_array) {
		INFO("Downloading $enc_url");
		my (undef, $tmp) = tempfile('download.XXXXXX', DIR => notaint($dir));
		my $resp = USER_AGENT->get( $enc_url, ':content_file' => $tmp);
		unless ($resp->is_success) {
			ERROR("Downloading $enc_url failed:");
			ERROR($resp->status_line);
			unlink($tmp);
			next;
		}

		my $exp_len = $resp->header('Content-Length');
		my $act_len = -s $tmp;
		if (defined $exp_len && $exp_len != $act_len) {
			# Thank you, Virginia Foundation for the Humanities.
			ERROR("Download truncated; expected $exp_len but got $act_len");
			ERROR("Run Podist download to try this one again");
			unlink($tmp);
			next;
		}

		my $name = $resp->filename;
		DEBUG("Server's name: $name");

		# Sanitize
		$name =~ tr/-_.a-zA-Z0-9//cd;

		# Figure filename suffix
		my $ctype = lc $resp->content_type;
		my $suffix;
		if (exists $SUFFIX_MAP{$ctype}) {
			$suffix = $SUFFIX_MAP{$ctype};
		} elsif ($name =~ /\.(mp3|ogg)$/) {
			if ('text/plain' eq $ctype) {
				$suffix = $1;
				WARN("Server broken; $enc_url gave us text/plain for $suffix");
			} elsif (-1 == index($ctype, '/')) {
				# seems podcastdownload.npr.org often gives a date(!) in
				# the content-type header. WTF. Confirmed with
				# Wireshark. But its only sometimes...
				$suffix = $1;
				WARN("Server broken; $enc_url gave WTF $ctype for $suffix");
			} else {
				$suffix = 'wtf';
				ERROR("Got $ctype for $suffix at $enc_url; will not use...");
			}
		} else {
			$suffix = 'wtf';
		}

		DEBUG("Content-Type: $ctype; suffix: $suffix");

		$name =~ /\.$suffix$/
			or $name .= ".$suffix";

		# Prefix enclosure number, guaranteeing uniqueness.
		$name = sprintf("%04i_%s", $enc_no, $name);

		# Rename
		DEBUG("Renaming to: $name");
		rename($tmp, notaint("$dir/$name"));

		$upd->execute($name, $enc_no);
	}
}

sub status {
	my $tab = Text::ASCIITable->new({
			outputWidth => 72,
			headingText => 'Current Feed Status'
	});
	$tab->setCols('Feed', 'Casts', 'Hours', '%Dwnld', '%Plst', 'Upl');
	$tab->addRow(@$_[1..6]) foreach @{DBH->selectall_arrayref(<<QUERY)};
SELECT
	feed_enabled,
    feed_name,
    COUNT(e.enclosure_no),
    ROUND(SUM(e.enclosure_time)/3600),
    SUM(CASE WHEN e.enclosure_file IS NULL THEN 0 ELSE 100 END)/COUNT(*),
    SUM(CASE WHEN e.playlist_no IS NULL THEN 0 ELSE 100 END)/COUNT(*) AS pct,
    SUM(CASE WHEN e.playlist_no IS NULL THEN 1 ELSE 0 END) AS cnt
  FROM
    feeds f
    LEFT JOIN enclosures e ON (f.feed_no = e.feed_no)
  WHERE
    COALESCE(e.enclosure_use,1) = 1
  GROUP BY feed_name
  HAVING
    f.feed_enabled = 1 OR cnt > 0
  ORDER BY CASE cnt WHEN 0 THEN 1 ELSE 0 END, LOWER(feed_name)
QUERY
	print $tab, "\n";

	$tab = Text::ASCIITable->new({
			outputWidth => 72,
			headingText => 'New Hours per Day over Various Time Periods'
	});
	$tab->setCols(qw(Feed 2d 7d 30d 90d 4ever));
	$tab->alignCol($_, 'right') foreach(qw(2d 30d 90d 4ever));
	my $sth = DBH->prepare(<<QUERY);
SELECT
    CASE WHEN f.feed_enabled = 0 THEN 'OFF - ' ELSE '' END || f.feed_name,
    SUM(
      CASE WHEN e.enclosure_when + 2*86400 >= 0+strftime('%s', 'now')
        THEN e.enclosure_time
        ELSE 0
      END)/(2*3600) AS "48h",
    SUM(
      CASE WHEN e.enclosure_when + 7*86400 >= 0+strftime('%s', 'now')
        THEN e.enclosure_time
        ELSE 0
      END)/(7*3600) AS "168h",
    SUM(
      CASE WHEN e.enclosure_when + 30*86400 >= 0+strftime('%s', 'now')
        THEN e.enclosure_time
        ELSE 0
      END)/(30*3600) AS "720h",
    SUM(
      CASE WHEN e.enclosure_when + 90*86400 >= 0+strftime('%s', 'now')
        THEN e.enclosure_time
        ELSE 0
      END)/(90*3600) AS "2160h",
    CASE WHEN f.feed_enabled = 1 THEN
      SUM(
        e.enclosure_time
      )/((
        MAX(e.enclosure_when)-MIN(e.enclosure_when)
      )/24)
    ELSE 0
    END AS "4ever"
  FROM
    feeds f
    LEFT JOIN enclosures e ON (
      f.feed_no = e.feed_no AND e.enclosure_use = 1
    )
  GROUP BY f.feed_no
  ORDER BY
    f.feed_enabled DESC, "4ever" DESC
QUERY
	$sth->execute;
	my @total = (0)x($sth->{NUM_OF_FIELDS}-1);
	while (my ($n, @times) = $sth->fetchrow_array) {
		pairwise { our ($a, $b); $a += ($b // 0) } @total, @times;
		$tab->addRow($n, map format_perday($_), @times);
	}
	$tab->addRowLine;
	$tab->addRow('TOTAL', map format_perday($_), @total);
	$tab->addRow('', map sprintf("%im", $_*60), @total);
	print $tab;
}

sub format_perday {
	defined $_[0]
		or return 'N/A';
	my $r = sprintf('%04.2f', $_[0]);
	'0.00' eq $r ? $_[0] == 0 ? '' : 'T' : $r;
}

sub find_file {
	my ($name, $playlist_no) = @_;
	my $d_pending = CONFIG->{storage}{pendingmedia};
	my $d_plist = CONFIG->{storage}{playlistedmedia};
	my $full_name;
	if (defined $playlist_no) {
		$full_name = (-e "$d_plist/$playlist_no/$name")
			? "$d_plist/$playlist_no/$name"
			: "$d_plist/$name";
	} else {
		$full_name = "$d_pending/$name";
	}

	return (-e $full_name) ? $full_name : undef;
}

sub hasherize {
	my $sth = DBH->prepare(<<QUERY);
SELECT enclosure_no, enclosure_file, playlist_no
  FROM enclosures
  WHERE
    enclosure_file IS NOT NULL
    AND enclosure_hash IS NULL
QUERY

	my $upd = DBH->prepare(<<QUERY);
UPDATE enclosures
  SET enclosure_hash = ?
  WHERE enclosure_no = ?
QUERY

	TRACE("Finding media without hash in db");
	$sth->execute;

	my $ctx = Digest->new('SHA-256')
		or LOGDIE("Couldn't get SHA-256 digest");
	while (my ($enc_no, $enc_file, $enc_plist) = $sth->fetchrow_array) {
		my $file = find_file($enc_file, $enc_plist);
		unless (defined $file) {
			WARN("Couldn't find file for #$enc_no ($enc_file)");
			next;
		}

		$ctx->reset;
		if (open my $fh, '<:raw', $file) {
			$ctx->addfile($fh);
			close $fh or LOGDIE("Close on $file failed: $!");
		} else {
			ERROR("Could not open $file: $!");
			next;
		}
		my $hash = 'sha256:' . $ctx->b64digest;

		TRACE("$enc_file: $hash");
		$upd->execute($hash, $enc_no);
	}
}

sub originalize {
	TRACE("Marking duplicates as don't use.");
	my $dups = DBH->selectall_arrayref(<<QUERY);
SELECT DISTINCT
    e2.enclosure_no, e2.enclosure_file
  FROM
    enclosures e1 JOIN enclosures e2 ON (
      e1.enclosure_hash = e2.enclosure_hash
    )
  WHERE
    e1.enclosure_no < e2.enclosure_no 
    AND e1.enclosure_use = 1 AND e2.enclosure_use = 1
    AND e2.playlist_no IS NULL
QUERY
	
	my $mark = DBH->prepare(<<QUERY);
UPDATE enclosures SET enclosure_use = 0 WHERE enclosure_no = ?
QUERY
	foreach my $dup (@$dups) {
		INFO("Duplicate: $dup->[1]; setting enclosure_use=0");
		$mark->execute($dup->[0]);
	}
}

sub stopwatch {
	my $sth = DBH->prepare(<<QUERY);
SELECT enclosure_no, enclosure_file
  FROM enclosures
  WHERE
    enclosure_file IS NOT NULL
    AND enclosure_time IS NULL
    AND enclosure_use = 1
QUERY

	my $upd = DBH->prepare(<<QUERY);
UPDATE enclosures
  SET enclosure_time = ?
  WHERE enclosure_no = ?
QUERY

	TRACE("Finding media without length in db");
	$sth->execute;

	my $dir = CONFIG->{storage}{pendingmedia};
	while (my ($enc_no, $enc_file) = $sth->fetchrow_array) {
		my $len;
		unless ($enc_file =~ /\.(.{3})$/) {
			ERROR("Could not find suffix in $enc_file");
			ERROR("This shouldn't happen, as wel always set a suffix. WTF.");
			next;
		}

		my $file = notaint("$dir/$enc_file");
		given ($1) {
			when ('mp3') {
				my $inf = get_mp3info($file);
				if ($inf) {
					$len = $inf->{SECS};
				} else {
					WARN("Could not get length of $file");
				}
			}
			when ('ogg') {
				my $ogg = Ogg::Vorbis::Header->new($file);
				if ($ogg) {
					$len = $ogg->info('length');
				} else {
					WARN("Ogg parser doesn't think $file is ogg");
				}
			}
			default {
				ERROR("Don't know how to get length of $1 files");
			}
		}

		defined $len && 0 == $len
			and WARN("Got length of 0 for $file; probably wrong!");

		DEBUG("$enc_file: " . (defined $len ? $len : 'undef'));
		$upd->execute($len, $enc_no);
	}
}

sub playlist {
	DBH->do('INSERT INTO playlists(playlist_ctime) VALUES (?)', {}, time());

	my $p_no = DBH->last_insert_id('', '', 'playlists', 'playlist_no')
		or LOGDIE("Could not get playlist number");

	my $plist_dir = notaint(CONFIG->{storage}{playlistedmedia}."/$p_no");
	-d $plist_dir
		or mkpath $plist_dir
		or LOGDIE("Could not create playlist media directory $plist_dir: $!");
	TRACE("Using playlist dir $plist_dir");

	my @randoms = find_random_items();
	my @playlist = ();
	my @bans;
	my $duration = 0;
	my $last_feed = 0; # feed_no's start at 1, avoid undef warnings
	my $consec = 0;
	my %feed_cnts;;
	my $since_rand_itms = 0;
	my $since_rand_time = 0;
	my $random_m = CONFIG->{playlist}{randomchancem};
	my $random_b = CONFIG->{playlist}{randomchanceb};
	my $random_func = lc(CONFIG->{playlist}{randomchancefunc});
	my $random_mode = lc(CONFIG->{playlist}{randomchancemode});

	if (CONFIG->{playlist}{announcebegin}) {
		push @playlist, announce(begin => $plist_dir, {
			p_no => $p_no,
			p_next => 1+$p_no,
		});
	}

	my $mark = DBH->prepare(<<QUERY);
UPDATE enclosures
  SET playlist_no = ?, playlist_so = ?
  WHERE enclosure_no = ?
QUERY

	until ($duration >= CONFIG->{playlist}{targetduration}
			|| @playlist >= CONFIG->{playlist}{maximumfiles})
	{
		my $only_feed = '1';
		my $order;
		my $where = playlist_valid_where(scalar @playlist,
			$duration, $last_feed, $consec, \@bans);
		TRACE("Rules-enforcing WHERE: $where");

		# Figure the choice method
		if (CONFIG->{playlist}{choicemethod} =~ /RandomFeed/i) {
			($only_feed) = DBH->selectrow_array(<<QUERY);
SELECT DISTINCT feed_no FROM valids
  WHERE $where
  ORDER BY random() LIMIT 1
QUERY
			$order = 'random()';
			$only_feed
				or last;
			TRACE("Picked feed $only_feed");
			$only_feed = "feed_no = $only_feed";
		} else {
			given (lc(CONFIG->{playlist}{choicemethod})) {
				when ('random')  { $order = 'random()' }
				when ('longest') { $order = 'enclosure_time DESC' }
				when ('oldest')  { $order = 'enclosure_when ASC' }
				default { LOGIDE("Unknown ChoiceMethod: $_") };
			}
		}
		TRACE("ORDER BY $order");

		# Chose an item.
		my ($feed_no, $enc_no, $enc_file, $enc_time)
			= DBH->selectrow_array(<<QUERY);
SELECT feed_no, enclosure_no, enclosure_file, enclosure_time
  FROM valids
  WHERE ($where) AND ($only_feed)
  ORDER BY $order
  LIMIT 1
QUERY
		$enc_no
			or last;
		DEBUG("Picked feed $feed_no, enc $enc_no, dur $enc_time");

		push @playlist, $enc_file;
		$duration += $enc_time;

		if ($feed_no == $last_feed) {
			++$consec;
		} else {
			$last_feed = $feed_no;
			$consec = 1;
		}

		if (++$feed_cnts{$feed_no} >= CONFIG->{playlist}{maximumperfeed}) {
			push @bans, $feed_no;
		}

		$mark->execute($p_no, scalar(@playlist), $enc_no);

		# Update random stats
		++$since_rand_itms;
		$since_rand_time += $enc_time;

		# Randomly add a random item, maybe.
		my $add_random = 0;
		my $x
			= ('time' eq $random_mode) ? $since_rand_time : $since_rand_itms;
		my $chance = $x * $random_m + $random_b;
		TRACE("Random chance = $chance");
		if (rand() < $chance) {
			my $item = $randoms[int rand @randoms];
			DEBUG("Adding random item $item");
			push @playlist, $item;

			$since_rand_time = 0;
			$since_rand_itms = 0;

			if (CONFIG->{playlist}{resetconsecutive}) {
				$consec = 0;
				$last_feed = 0;
			}
		}


		DEBUG("Playlist files=" . scalar(@playlist) . "; dur=$duration");
	}

	TRACE("Done with playlist add loop - doing constraint checks");
	$duration < CONFIG->{playlist}{minimumduration}
		and LOGDIE("Playlist too short; abort");
	@playlist < CONFIG->{playlist}{minimumfiles}
		and LOGDIE("Playlist has too few files; abort");

	if (CONFIG->{playlist}{announceend}) {
		push @playlist, announce(end => $plist_dir, {
			p_no => $p_no,
			p_next => 1+$p_no,
		});
	}

	my $fname = notaint(
		sprintf("%s/Playlist %03i.m3u", CONFIG->{storage}{playlists}, $p_no));
	DEBUG("Writing playlist $fname");
	write_file($fname, map $_ =~ m!^/! ? "$_\n" : "$plist_dir/$_\n", @playlist);
	TRACE("Moving files");
	foreach my $f (@playlist) {
		next if $f =~ m!^/!; # prob random item
		my $old = notaint(CONFIG->{storage}{pendingmedia}."/$f");
		my $new = notaint("$plist_dir/$f");
		
		-e $new
			and LOGDIE("WTF - $new already exists");

		rename($old, $new)
			or LOGDIE("could not rename $old to $new");
	}
		
}

sub announce {
	my ($event, $dir, $subs) = @_;

	$event = lc $event;
	exists CONFIG->{speech}{message}{$event}
		or LOGDIE("Tried to announce unconfigured message $event");

	my $msg = CONFIG->{speech}{message}{$event};
	TRACE("Message for $event: $msg; doing subs");

	$msg =~ s/__(.+?)__/$subs->{lc $1}/ge;

	return speak($msg => $dir);
}

sub speak {
	my ($what, $dir) = @_;

	my (undef, $tmp_wav) = tempfile('speech.XXXXXX', DIR => notaint($dir), SUFFIX => '.wav');

	TRACE("Speaking $what");

	CONFIG->{speech}{engine} =~ /^festival$/i
		or LOGDIE("Festival is the only supported TTS engine, sorry.");

	my $voice = CONFIG->{speech}{voice};
	$voice =~ /^\(?(?:voice_)?([a-z_]+)\)?$/
		or LOGDIE("Invalid voice syntax: $voice");
	$voice = "(voice_$voice)";

	my $dBFS = CONFIG->{speech}{volume};
	$dBFS =~ /^-?(\d+)(?:dbfs)?$/i
		or LOGDIE("Invalid volume: $dBFS");
	$dBFS = "-${1}dBFS";

	TRACE("Invoking festival w/ voice $voice");
	run3 [qw(text2wave -eval), $voice, qw(-f 44100 -o), $tmp_wav], \$what
		or LOGDIE("text2wave failed: $! $?");

	TRACE("Normalizing output to $dBFS");
	run3 [qw(normalize-audio -q -a), $dBFS, $tmp_wav]
		or LOGDIE("normalize-audio failed: $! $?");

	given (CONFIG->{speech}{format}) {
		when ('wav') { return $tmp_wav }
		when ('mp3') {
			my (undef, $tmp_mp3) = tempfile('speech.XXXXXX', DIR => notaint($dir), SUFFIX => '.mp3');
			TRACE("Encoding mp3");
			run3 [qw(lame --quiet --preset medium), $tmp_wav, $tmp_mp3]
				or LOGDIE("lame failed: $! $?");
			unlink $tmp_wav;
			return $tmp_mp3;
		}
		when ('ogg') {
			my (undef, $tmp_ogg) = tempfile('speech.XXXXXX', DIR => notaint($dir), SUFFIX => '.ogg');
			TRACE("Encoding ogg");
			run3 [qw(oggenc -Q -q0 -o), $tmp_ogg, $tmp_wav]
				or LOGDIE("oggenc failed: $! $?");
			unlink $tmp_wav;
			return $tmp_ogg;
		}
		default { LOGDIE("Uknown format $_") }
	}

	LOGDIE("Unreachable code reached");
}

sub all_playlists {
	while (1) {
		playlist();
		DBH->commit;
	}
}

sub playlist_valid_where {
	my ($cur_files, $cur_time, $last_feed, $consec, $bans) = @_;

	my $not_in;
	if ($consec >= CONFIG->{playlist}{maximumconsecutive}) {
		$not_in = join(q{,}, $last_feed, @$bans);
	} else {
		$not_in = join(q{,}, @$bans);
	}
	$not_in = ('' ne $not_in) ? "feed_no NOT IN ($not_in)" : '1';

	my $time_constraint = 1;
	if ($cur_files >= CONFIG->{playlist}{minimumfiles}) {
		my $mx = CONFIG->{playlist}{maximumduration} - $cur_time;
		$time_constraint = "enclosure_time <= $mx";
	};

	return "$not_in AND $time_constraint";
}

sub find_random_items {
	my $dir = 
	my @files;

	find({
			wanted => sub {
				-f -r $File::Find::fullname
					and push @files, $File::Find::fullname;
			},
			follow  => 1,
			untaint => 1,
		},
		notaint(CONFIG->{storage}{randommedia}));

	return @files;
}

sub help {
	print STDERR <<HELP;
Usage - $0 command arguments

Commands are:

   subscribe, new, add Name URL
      Subscribe to a new podcast named Name with feed at URL. URL
      should be the RSS or Atom feed. Name is anything you want, but
      must be unique for all your subscribed podcasts. Remember to quote
      Name and URL for your shell.

   catch
     Run the podcatcher. The same as fetch, download, and stopwatch (in
     that order) below.

   fetch
      Grabs the subscribed RSS feeds and adds all the enclosures to the
      database. Does not actually download the enclosures.

   download
      Downloads enclosures that are in the database (from fetch) but not
      yet downloaded.

   hash
      Calculates the hash for each downloaded podcast and stores this in
      the database. The hash is used to catch duplicates.

   originalize
      Finds duplicate podcasts based on their hash, and marks the second
      (and third, etc.) copies such that they won't be used.

   stopwatch
      Calculates how long each downloaded podcast is, and stores this
      information in the database.

   playlist
      Builds playlists based on downloaded, stopwatched media in the
      database.

   status
      Shows a summary of what's in the database.
   
   help
      Duh.
HELP
}

sub notaint {
	$_[0] =~ /^(.+)$/s;
	$1;
}

sub setup {
	my $confdir = notaint("$ENV{HOME}/.podist");

	-d $confdir
		or mkdir $confdir
		or die "Could not mkdir $confdir: $!";

	# read config and install sub
	my $config = setup_config($confdir);
	*CONFIG = sub() { $config };

	init_logging();

	if (CONFIG->{notyetconfigured}) {
		FATAL(<<ERR);
Podist has not been configured. Please review this configuration file
and set NotYetConfigured to false:
    $confdir/podist.conf
ERR
		exit 1;
	}

	# Untaint the environment
	$ENV{PATH} = notaint($ENV{PATH});

	# Setup our output directories.
	setup_dirs();

	# setup the DB and install DBH subroutine
	my $dbh = setup_db();
	*DBH = sub() { $dbh };
}

sub setup_dirs {

	for my $d (
		@{CONFIG->{storage}}{
			qw(pendingmedia playlistedmedia
				playlists randommedia)
		})
	{
		-d $d
			or mkpath(notaint($d))
			or LOGDIE("Could not mkpath($d): $!");
	}
}

sub init_logging {
	if (CONFIG->{logging}{simple}) {
		my $level = uc(CONFIG->{logging}{level});
		Log::Log4perl->init(\<<L4P);
log4perl.category = $level, Screen
log4perl.appender.Screen = Log::Log4perl::Appender::ScreenColoredLevels
log4perl.appender.Screen.layout = Log::Log4perl::Layout::PatternLayout::Multiline
log4perl.appender.Screen.layout.ConversionPattern = [%r] %m%n
L4P
	} else {
		Log::Log4perl::init(CONFIG->{logging}{config});
	}
	TRACE("Log4perl configured and hopefully ready.");
}

sub setup_config {
	my ($confdir) = @_;
	my $conffile = "$confdir/podist.conf";

	my $default_config = <<CONF;
# Once you've reviewed this file, change this to false.
NotYetConfigured true
DataDir $confdir # e.g., \$HOME/.podist

<storage>
	PendingMedia    \$HOME/Podist/media-pending
	PlaylistedMedia \$HOME/Podist/media-listed
	Playlists       \$HOME/Podist/playlists
	RandomMedia     \$HOME/Podist/playlists/random
</storage>

<playlist>
	# These are constraints for playlist generation. They are followed
	# as:
	#   1. If there are less than MinimumFiles, add any valid file (defined
	#      below)
	#   2. If there are MaximumFiles, stop. This playlist is done.
	#   3. If the playlist duration is less than TargetDuration, add any
	#      valid file such that the duration does not exceed
	#      MaximumDuration. If there are no files to add, stop, this
	#      playlist is done.
	#   4. If the playlist duration is at least TargetDuration, stop.
	#      This playlist is done.
	# Those are repeated until hitting a "stop", of course.
	#
	# As a final check, before comitting the playlist, if the total
	# length is less than MinimumDuration, abort.
	#
	# A valid file is any file that is:
	#   - the oldest unplaylisted file in its feed, if the feed is ordered
	#   - any unplaylisted file in an unordered feed
	# and does not put more than MaxConsecutive files from the same feed
	# in a row and does not exceed MaximumPerFeed files from that feed
	# in the current playlist.
	MinimumDuration    1800
	TargetDuration     3600
	MaximumDuration    7200
	MinimumFiles       1
	MaximumFiles       5
	MaximumConsecutive 2
	MaximumPerFeed     4

	# How do we pick between multiple valid options, all of which follow
	# the rules?
	#   - Random: pick completely at random
	#   - RandomFeed: pick at random, but make sure each feed has an
	#                 equal chance even if feed A has 10 eps, and feed B
	#                 has 300.
	#   - Longest: Pick the longest (duration) 
	#   - Oldest: Pick the oldest
	ChoiceMethod       RandomFeed
	
	# What should the chance be of throwing in a random item after each
	# played item?
	#   - Mode: Count, Time
	#   - M: Slope
	#   - B: Y-intercept, aka constan in constant func
	# That is, f(x) = mx + b
	#
	# NOTE: Random items are ignored in length/duration constraints
	#       (above).
	RandomChanceMode   Time
	RandomChanceM      1/7200
	RandomChanceB      0.2

	# If we insert a random item, does this reset the consecutive same
	# podcast counter?
	ResetConsecutive   yes

	# Shall we put an announcement at the beginning and/or end of the
	# playlists we generate using a TTS (see the speech section below)
	AnnounceBegin Yes
	AnnounceEnd   Yes
</playlist>

<speech>
	# Which TTS engine shall we use? Currently, only Festival is
	# supported.
	Engine Festival

	# The voice to use
	Voice rab_diphone

	# How loud to make the audio
	Volume 12dbFS

	# Which format to get the audio in enventually. Options are:
	#   wav, mp3, ogg (listed largest -> smallest)
	Format ogg

	# What to say
	<message>
		Begin   Start of playlist __CURRENT__
		End     End of playlist __CURRENT__.
	</message>
</speech>

<database>
	DSN dbi:SQLite:dbname=\$DataDir/podist.db
	Username   # fill in if DB requires
	Password   # fill in if DB requires
</database>

<logging>
	Simple true
	Level info   # fatal | error | warn | info | debug | trace

	### Alternatively, for more control,
	# Simple false
	# Config \$DataDir/log4perl.conf
</logging>
CONF

	-e $conffile
		or write_file($conffile, \$default_config);

	# Don't repeat yourself.
	#
	# Unfortunately, we need the string representation of the config (so
	# we can have comments in it), hopefully this isn't too slow...
	my %parse_opts_common = (
		-AllowMultiOptions    => 0,
		-LowerCaseNames       => 1,
		-UseApacheInclude     => 1,
		-IncludeRelative      => 1,
		-IncludeDirectories   => 1,
		-IncludeGlob          => 1,
		-IncludeAgain         => 1,
		-MergeDuplicateBlocks => 1,
		-AutoLaunder           => 1,
		-AutoTrue              => 1,
		-InterPolateVars       => 1,
		-InterPolateEnv        => 1,
		-StrictVars            => 1,
		-SplitPolicy           => 'whitespace',

	);
	my $cg_def = new Config::General(
		-String               => $default_config,
		%parse_opts_common,
	);
	my %defs = $cg_def->getall;

	# Yes, in the first-use case, this will be the exact same as the
	# defaults, but oh well.
	my $cg_conf = new Config::General(
		-ConfigFile            => $conffile,
		-MergeDuplicateOptions => 1,
		-DefaultConfig         => \%defs,
		%parse_opts_common,
	);

	my $config = { $cg_conf->getall };

	# durations can have H or M after them; normalize to seconds. If
	# someone explicitly specified S for seconds, that's fine too...
	foreach my $v (qw(minimumduration targetduration maximumduration)) {
		$config->{playlist}{$v} =~ /^(\d+)\s*S$/i
			and $config->{playlist}{$v} = $1;
		$config->{playlist}{$v} =~ /^(\d+)\s*M$/i
			and $config->{playlist}{$v} = $1 * 60;
		$config->{playlist}{$v} =~ /^(\d+)\s*H$/i
			and $config->{playlist}{$v} = $1 * 3600;
	}

	# change fractions for RandomChanceM and RandomChanceB to decimals
	foreach my $v (qw(randomchancem randomchanceb)) {
		$config->{playlist}{$v} =~ m!(\d+)/(\d+)!
			and $config->{playlist}{$v} = $1/$2;
	}

	return $config;
}

use constant DB_VERSION => 1;

sub setup_db {
	TRACE("Connecting to the database.");
	my $dbh = DBI->connect(
		CONFIG->{database}{dsn},
		CONFIG->{database}{username},
		CONFIG->{database}{password},
		{
			AutoCommit       => 0,
			RaiseError       => 1,
			PrintError       => 0,
			FetchHashKeyName => 'NAME_lc',
		});

	my ($vers) = $dbh->selectrow_array('PRAGMA user_version');
	$vers > DB_VERSION
		and die "Database is from newer version of this program";

	if (0 == $vers) {
		INFO("Creating Podist database.");
		# need to create db.
		$dbh->do(<<SQL);
CREATE TABLE feeds (
  feed_no        INTEGER   NOT NULL PRIMARY KEY,
  feed_url       TEXT      NOT NULL UNIQUE,
  feed_name      TEXT      NOT NULL UNIQUE,
  feed_enabled   INTEGER   NOT NULL DEFAULT 1,
  feed_ordered   INTEGER   NOT NULL DEFAULT 1,
  feed_all_audio INTEGER   NOT NULL DEFAULT 1,
  CONSTRAINT enabled_is_bool CHECK (feed_enabled IN (0,1)),
  CONSTRAINT ordered_is_bool CHECK (feed_ordered IN (0,1))
  CONSTRAINT all_audio_is_bool CHECK (feed_all_audio IN (0,1))
)
SQL
		$dbh->do(<<SQL);
CREATE TABLE playlists (
  playlist_no    INTEGER   NOT NULL PRIMARY KEY,
  playlist_ctime INTEGER   NOT NULL
)
SQL
		$dbh->do(<<SQL);
CREATE TABLE enclosures (
  enclosure_no     INTEGER   NOT NULL PRIMARY KEY,
  feed_no          INTEGER   NOT NULL REFERENCES feeds,
  enclosure_url    TEXT      NOT NULL UNIQUE,
  enclosure_file   TEXT      NULL UNIQUE,
  enclosure_hash   TEXT      NULL,
  enclosure_when   INTEGER   NOT NULL, -- unix timestamp
  enclosure_time   REAL      NULL, -- length in seconds
  enclosure_use    INTEGER   NOT NULL DEFAULT 1,
  playlist_no      INTEGER   NULL REFERENCES playlists,
  playlist_so      INTEGER   NULL,
  UNIQUE(playlist_no, playlist_so),
  CONSTRAINT use_is_bool CHECK (enclosure_use IN (0,1))
)
SQL
		$dbh->do(<<SQL);
CREATE INDEX enclosusures_enclosure_hash ON enclosures(enclosure_hash)
SQL
		$dbh->do(<<SQL);
CREATE VIEW oldest_unplayed AS
  SELECT feed_no, min(enclosure_when) AS oldest
    FROM enclosures
    WHERE
      enclosure_file IS NOT NULL
      AND playlist_no IS NULL
      AND enclosure_use = 1
    GROUP BY feed_no
SQL
		$dbh->do(<<SQL);
CREATE VIEW valids AS
  SELECT
    f.feed_ordered    AS feed_ordered,
    e.enclosure_no    AS enclosure_no,
    e.feed_no         AS feed_no,
    e.enclosure_url   AS enclosure_url,
    e.enclosure_file  AS enclosure_file,
    e.enclosure_when  AS enclosure_when,
    e.enclosure_time  AS enclosure_time
  FROM
    feeds f
    JOIN enclosures e ON (f.feed_no = e.feed_no)
    LEFT JOIN oldest_unplayed ou ON (e.feed_no = ou.feed_no)
  WHERE
    (NOT f.feed_ordered OR e.enclosure_when = ou.oldest)
    AND e.enclosure_file IS NOT NULL
    AND e.enclosure_time IS NOT NULL
    AND e.playlist_no IS NULL
    AND e.enclosure_use = 1
SQL
		$dbh->selectrow_array('PRAGMA user_version = 1');
		$dbh->commit;
		TRACE("Database creation done.");
	} elsif (1 == $vers) {
		DEBUG("Version 1 database found");
		# current, do nothing.
	} else {
		LOGDIE "BUG: Unknown (but not future!) database version";
	}

	# Enable foreign keys
	$dbh->do('PRAGMA foreign_keys = ON');

	return $dbh;
}

sub USER_AGENT() {
	state $agent;
	unless ($agent) {
		$agent = LWP::UserAgent->new(
			agent => 'Podist/0.1 ', # space at end: append _agent
			env_proxy => 1,
			keep_alive => 4, # Some podcasts love redirects
			cookie_jar => { }, # temp only
		);

		$agent->default_header(
			Accept => 'application/rss+xml, application/atom+xml, audio/ogg, audio/x-ogg, audio/mpeg, application/rdf+xml;q=0.9, application/xml;q=0.8, text/xml;q=0.8, application/ogg;q=0.8, audio/*;q=0.7, */*;q=0.1'
		);
	}

	return $agent;
}
