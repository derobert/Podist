#!/usr/bin/perl -w

# Podist - a podcatcher that generates playlists
# Copyright ©2008–2015  Anthony DeRobertis
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use Config::General;
use DBI;
use Digest;
use File::Copy qw(move);
use File::Find qw(find);
use File::Path qw(mkpath);
use File::Spec;
use File::Slurp qw(write_file);
use File::Temp qw(tempfile);
use Getopt::Long;
use IPC::Run3;
use List::MoreUtils qw(pairwise);
use Log::Log4perl qw(:easy :no_extra_logdie_message);
use LWP::UserAgent;
use MP3::Info qw(get_mp3info);
use Ogg::Vorbis::Header::PurePerl;
use POSIX qw(strftime);
use Text::ASCIITable;
use XML::FeedPP;
use Carp qw(longmess);

BEGIN { -t STDOUT and $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }
use Pod::Usage;

use FindBin;
use lib "$FindBin::RealBin/lib";
use Podist::Database;

use feature 'state';
use feature 'say';
use strict;

my $DB;           # set by setup
sub CONFIG();     # defined by setup
sub COMMAND();    # defined by register_commands
sub USER_AGENT(); # below

my %SUFFIX_MAP = (
	'audio/mpeg'        => 'mp3',    # RFC 3003
	'audio/x-mpeg'      => 'mp3',    # pre-2000
	'audio/x-mp3'       => 'mp3',    # err?
	'audio/mp3'         => 'mp3',    # umm?
	'x-audio/mp3'       => 'mp3',    # idiots
	'audio/ogg'         => 'ogg',
	'audio/x-ogg'       => 'ogg',
	'application/ogg'   => 'ogg',
	'application/x-ogg' => 'ogg',
);
my %MIME_MAP = (
	mp3 => 'audio/mpeg',
	ogg => 'audio/ogg',
);

exit go();
### functions only below ###

sub go {
	my $gopts = parse_global_opts();
	setup($gopts->{config_dir});

	# Don't do this until after setup, because we need log4perl ready
	# first!
	$SIG{__DIE__} = sub {
		if ($^S) {
			# We're in an eval {} and don't want log
			# this message but catch it later
			return;
		}
		$Log::Log4perl::caller_depth++;
		LOGDIE longmess(@_);
	};

	unless (@ARGV) {
		FATAL "You need to specify a command. Try $0 --help";
		exit 1;
	}

	register_commands();

	my $cmd = lc(shift @ARGV);
	unless (exists COMMAND->{$cmd}) {
		FATAL "Unknown command '$cmd'. Try $0 --help";
		exit 1;
	}

	TRACE("Dispatching command '$cmd'");
	COMMAND->{$cmd}(@ARGV);

	TRACE("Command done; committing");
	$DB->commit();

	return 0;
}

sub register_commands {
	*COMMAND = sub() {
		{
			add       => \&add_podcast,
			new       => \&add_podcast,
			subscribe => \&add_podcast,

			catch     => \&catch,
			fetch     => \&fetch,
			download  => \&download,
			stopwatch => \&stopwatch,
			hash      => \&hasherize,
			hasherize => \&hasherize,
			originalize => \&originalize,

			playlist  => \&playlist,
			all_playlists => \&all_playlists,
			archive   => \&archive,
			
			feed      => \&feed,

			status    => \&status,
			list      => \&list,
		    cleanup   => \&cleanup,
		};
	};
	TRACE("Commands registered");
}

sub add_podcast {
	my ($name, $url) = @_;

	$DB->do(<<QUERY, {}, $name, $url);
INSERT INTO feeds(feed_name, feed_url) VALUES(?, ?)
QUERY
}

sub catch {
	fetch();
	download();
	stopwatch();
	hasherize();
	originalize();
}

sub fetch {
	my $go = Getopt::Long::Parser->new(
		config => [qw( gnu_compat require_order )]);

	my (@only_feeds, $override_fetch_limit);
	$go->getoptions(
		'feeds|f=i{1,}' => \@only_feeds,
		'new-limit|limit|fetch-limit|l=i' => \$override_fetch_limit
	) or pod2usage(2);

	my $sth_feeds;
	if (@only_feeds) {
		TRACE("Grabbing specified feed @{[join q{,}, @only_feeds]} from DB");
		$sth_feeds = $DB->prepare(<<QUERY);
SELECT
    feed_no, feed_name, feed_url, feed_all_audio,
    feed_limit_amount, feed_limit_period
  FROM feeds
  WHERE feed_no IN (@{[join q{,}, @only_feeds]})
  ORDER BY feed_no
QUERY
	} else {
		TRACE("Finding enabled feeds in db");
		$sth_feeds = $DB->prepare(<<QUERY);
SELECT
    feed_no, feed_name, feed_url, feed_all_audio,
    feed_limit_amount, feed_limit_period
  FROM feeds
  WHERE feed_enabled = 1
  ORDER BY feed_no
QUERY
	}
	$sth_feeds->execute;

	my $sth_used = $DB->prepare(<<QUERY);
SELECT COUNT(*)
  FROM fetches f JOIN articles a ON (f.fetch_no = a.fetch_no)
  WHERE a.article_use = 1 AND f.feed_no = ? AND f.fetch_when >= ?
QUERY

	FEED: while (my ($feed_no, $feed_name, $feed_url, $all_audio, $limit_amount, $limit_period)
		= $sth_feeds->fetchrow_array)
	{
		$sth_used->execute($feed_no, time-$limit_period);
		my ($limit_used) = $sth_used->fetchrow_array;
		$sth_used->finish;

		my $limit_remain = $override_fetch_limit
			// ($limit_amount - $limit_used);
		if ($limit_remain <= 0) {
			WARN("Skipping $feed_name (#$feed_no) because limit fully used.");
			next;
		}

		my $fetch_no = $DB->add_fetch($feed_no);
		INFO("Fetching $feed_name (feed#$feed_no, fetch#$fetch_no, limit=$limit_remain)");
		$DB->do("SAVEPOINT one_fetch");
		my $resp = USER_AGENT->get($feed_url);
		unless ($resp->is_success) {
			ERROR("Downloading of $feed_name from $feed_url failed:");
			ERROR($resp->status_line);
			$DB->finish_fetch($fetch_no, 'http_error');

			next; # ignore this feed
		}

		my $content_type = $resp->content_type;
		TRACE("Content-Type: $content_type");
		$content_type =~ m#^(application/((rss|atom|rdf)\+)?xml)|(text/xml)$ #x
			or WARN("Unexpected MIME type $content_type; bad things may happen");

		TRACE("Handing over to the feed parser");
		my $feed = eval {
			# workaround bug 661551
			my $content = $resp->decoded_content;
			$content =~ s/^\x{FEFF}//;
			XML::FeedPP->new($content, type => 'string');
		};
		if ($@) {
			ERROR("Feed parse exploded: $@");
			$DB->finish_fetch($fetch_no, 'parse_error');
			next;
		}
		unless ($feed) {
			ERROR("Feed parser failed.");
			next;
		}

		my ($date_last1, $date_last2);
		my $item_count = 0;
		ITEM: foreach my $item ($feed->get_item) {
			my $enc_url = $item->get('enclosure@url');
			(my $item_title = $item->title) =~ y/\x0a\x0d/ /;
			$item_title =~ s/^\s+//;
			$item_title =~ s/\s+$//;

			unless ($enc_url) {
				my $msg = "Item $item_title has no enclosure";
				$all_audio ? INFO($msg) : TRACE($msg);
				next;
			}

			my $enc_type = $item->get('enclosure@type');
			unless (!defined $enc_type || '' eq $enc_type || $enc_type =~ m#^(audio|x-audio|application)/(ogg|x-ogg|mpeg|x-mpeg|x-mp3|mp3)$ #x) {
				my $msg = "Skipping $item_title (uknown enclosure type $enc_type)";
				$all_audio ? WARN($msg) : TRACE($msg);
				next;
			}

			my $date = $item->get_pubDate_epoch;

			# KLUGE: fails if the date has spaces; work around...
			if (!$date && '' ne $item->get_pubDate_native) {
				TRACE("Space-normalizing date");
				$date = $item->get_pubDate_native;
				$date =~ s/^\s+//;
				$date =~ s/\s+$//;
				$date =~ s/\s+/ /g;
				$item->pubDate($date);
				$date = $item->get_pubDate_epoch;
			}

			if (!$date) {
				ERROR("@{[ $item->title ]}: get_pubDate_epoch failed");
				if (defined $date_last2) {
					if ($date_last2 > $date_last1) {
						# podcast is most-recent first
						WARN("Assuming one second BEFORE previous");
						$date = $date_last1 - 1;
					} elsif ($date_last2 < $date_last1) {
						# podcast is least-recent first
						WARN("Assuming one second AFTER previous");
						$date = $date_last1 + 1;
					} else {
						WARN("Assuming same date as previous two!");
						$date = $date_last1;
					}
				} elsif (defined $date_last1) {
					# randomly guess podcast is most-recent first; a lot
					# seem to be.
					WARN("Guessing most-recent first");
					WARN("Guessing one second BEFORE previous");
					$date = $date_last1 - 1;
				} else {
					WARN("Is first item; no f—ing clue what date to use");
					WARN("Using current time!");
					$date = time;
				}
				DEBUG("The time is now "
						. strftime("%F %H:%M:%S %Z", localtime($date))
						. ".\nDo you know where your podcasts are?");
			}

			my $article_no;
			my $article_uid = $item->guid;

			# parser fails to perform XML whitespace normalization...
			$article_uid =~ s/^\s+//;
			$article_uid =~ s/\s+$//;
			$article_uid =~ s/\s+/ /g;

			if (defined $article_uid && '' eq $article_uid) {
				TRACE("Ignoring blank guid");
				$article_uid = undef;    # thank you Stack Overflow Blog.
			}
			if (defined $article_uid) {
				$article_no = $DB->find_article(uid => $article_uid);
				TRACE("Checked for uid $article_uid in DB.");
			} else {
				$article_no
					= $DB->find_article(when => $date, title => $item_title);
				TRACE("Checked for title $item_title date $date in DB.");
			}
			if ($article_no) {
				TRACE("Skipping already-in-db article.");
				next;
			}

			my $article_use = 1;
			if ($item_title =~ CONFIG->{article}{titleignorere}) {
				INFO("Will set don't-use on title-ignored $item_title.");
				$article_use = 0;
			}

			$article_no = $DB->add_article(
				feed  => $feed_no,
				fetch => $fetch_no,
				use   => $article_use,
				uid   => $article_uid,
				title => $item_title,
				when  => $date
			);
			DEBUG("Added article $article_no to DB for \"$item_title\"");

			if ($article_use) {
				++$item_count;
				if ($item_count > $limit_remain) {
					ERROR("Feed $feed_name (#$feed_no) exceeded new article limit ($limit_remain). Rolling back.");
					$DB->do(q{ROLLBACK TO SAVEPOINT one_fetch});
					$DB->finish_fetch($fetch_no, 'Limit');
					next FEED;
				}
				my $enclosure_no = $DB->find_enclosure($enc_url);
				if (!$enclosure_no) {
					$enclosure_no = $DB->add_enclosure($enc_url);
					DEBUG(qq{Added enclosure $enclosure_no for "$enc_url".});
				}
				$DB->link_article_enclosure($article_no, $enclosure_no);
				TRACE("Linked enclosure $enclosure_no to article $article_no");
			}

			$date_last2 = $date_last1;
			$date_last1 = $date;
		}

		# we got here, so it's OK.
		$DB->finish_fetch($fetch_no, 'OK');
		$DB->do(q{RELEASE SAVEPOINT one_fetch});
	}
}

sub download {
	# We sort by URL in hopes of maximizing use of persistent
	# connections (HTTP Keepalive). Next sort by the number to make this
	# deterministic.
	TRACE("Finding undownloaded media");
	my $sth = $DB->prepare(<<QUERY);
SELECT DISTINCT e.enclosure_no, e.enclosure_url
  FROM enclosures e
  JOIN articles_enclosures ae ON (e.enclosure_no = ae.enclosure_no)
  JOIN articles a ON (ae.article_no = a.article_no)
  WHERE e.enclosure_file IS NULL
    AND e.enclosure_use = 1
    AND a.article_use = 1
  ORDER BY e.enclosure_url, e.enclosure_no
QUERY
	$sth->execute;

	my $upd = $DB->prepare(<<QUERY);
UPDATE enclosures
  SET enclosure_file = ?
  WHERE enclosure_no = ?
QUERY

	my $dir = CONFIG->{storage}{pendingmedia};

	while (my ($enc_no, $enc_url) = $sth->fetchrow_array) {
		INFO("Downloading $enc_url");
		my (undef, $tmp) = tempfile('download.XXXXXX', DIR => notaint($dir));
		my $resp = USER_AGENT->get( $enc_url, ':content_file' => $tmp);
		unless ($resp->is_success) {
			ERROR("Downloading $enc_url failed:");
			ERROR($resp->status_line);
			unlink($tmp);
			next;
		}

		my $exp_len = $resp->header('Content-Length');
		my $act_len = -s $tmp;
		if (defined $exp_len && $exp_len != $act_len) {
			# Thank you, Virginia Foundation for the Humanities.
			ERROR("Download truncated; expected $exp_len but got $act_len");
			ERROR("Run Podist download to try this one again");
			unlink($tmp);
			next;
		}

		my $name = $resp->filename;
		DEBUG("Server's name: $name");

		# Sanitize
		$name =~ tr/-_.a-zA-Z0-9//cd;

		# Figure filename suffix
		my $ctype = lc $resp->content_type;
		my $suffix;
		if (exists $SUFFIX_MAP{$ctype}) {
			$suffix = $SUFFIX_MAP{$ctype};
		} elsif ($name =~ /\.(mp3|ogg)$/) {
			if ('text/plain' eq $ctype) {
				$suffix = $1;
				WARN("Server broken; $enc_url gave us text/plain for $suffix");
			} elsif (-1 == index($ctype, '/')) {
				# seems podcastdownload.npr.org often gives a date(!) in
				# the content-type header. WTF. Confirmed with
				# Wireshark. But its only sometimes...
				$suffix = $1;
				WARN("Server broken; $enc_url gave WTF $ctype for $suffix");
			} else {
				$suffix = 'wtf';
				ERROR("Got $ctype for $suffix at $enc_url; will not use...");
			}
		} else {
			$suffix = 'wtf';
		}

		DEBUG("Content-Type: $ctype; suffix: $suffix");

		$name =~ /\.$suffix$/
			or $name .= ".$suffix";

		# Prefix enclosure number, guaranteeing uniqueness.
		$name = sprintf("%04i_%s", $enc_no, $name);

		# Rename
		DEBUG("Renaming to: $name");
		rename($tmp, notaint("$dir/$name"));

		$upd->execute($name, $enc_no);
	}
}

sub status {
	# 31,556,952 seconds = 1 (average) year on Gregorian calendar,
	# presuming 86400 seconds/day.
	my $tab = Text::ASCIITable->new({
			outputWidth => 72,
			headingText => 'Current Feed Status'
	});
	$tab->setCols('Feed', 'Casts', 'Hours', '%Dwnld', '%Plst', 'Upl', 'Oldest');
	$tab->addRow(@$_[1..7]) foreach @{$DB->selectall_arrayref(<<QUERY)};
SELECT
	feed_enabled,
    feed_name,
    COUNT(e.enclosure_no),
    ROUND(SUM(e.enclosure_time)/3600),
    SUM(CASE WHEN e.enclosure_file IS NULL THEN 0 ELSE 100 END)/COUNT(*),
    SUM(CASE WHEN e.playlist_no IS NULL THEN 0 ELSE 100 END)/COUNT(*) AS pct,
    SUM(CASE WHEN e.playlist_no IS NULL THEN 1 ELSE 0 END) AS cnt,
    CASE SUM(CASE WHEN e.playlist_no IS NULL THEN 1 ELSE 0 END)
      WHEN 0 THEN ''
      ELSE PRINTF('%0.2f', (STRFTIME('%s', 'now') - MIN(CASE WHEN e.playlist_no IS NULL THEN a.article_when ELSE null END))/31556952.0)
    END
  FROM
    feeds f
    LEFT JOIN articles a ON (f.feed_no = a.feed_no)
    LEFT JOIN articles_enclosures ae ON (a.article_no = ae.article_no)
    LEFT JOIN enclosures e ON (ae.enclosure_no = e.enclosure_no)
  WHERE
    COALESCE(e.enclosure_use,1) = 1 -- COALESCE due to LEFT JOIN
    AND COALESCE(a.article_use,1) = 1 -- COALESCE due to LEFT JOIN
  GROUP BY feed_name
  HAVING
    f.feed_enabled = 1 OR cnt > 0
  ORDER BY CASE cnt WHEN 0 THEN 1 ELSE 0 END, LOWER(feed_name)
QUERY
	print $tab, "\n";

	$tab = Text::ASCIITable->new({
			outputWidth => 72,
			headingText => 'New Hours per Day over Various Time Periods'
	});
	$tab->setCols(qw(Feed 2d 7d 30d 90d 4ever));
	$tab->alignCol($_, 'right') foreach(qw(2d 30d 90d 4ever));
	my $sth = $DB->prepare(<<QUERY);
SELECT
    f.feed_enabled,
    CASE WHEN f.feed_enabled = 0 THEN 'OFF - ' ELSE '' END || f.feed_name,
    SUM(
      CASE WHEN a.article_when + 2*86400 >= 0+strftime('%s', 'now')
        THEN e.enclosure_time
        ELSE 0
      END)/(2*3600) AS "48h",
    SUM(
      CASE WHEN a.article_when + 7*86400 >= 0+strftime('%s', 'now')
        THEN e.enclosure_time
        ELSE 0
      END)/(7*3600) AS "168h",
    SUM(
      CASE WHEN a.article_when + 30*86400 >= 0+strftime('%s', 'now')
        THEN e.enclosure_time
        ELSE 0
      END)/(30*3600) AS "720h",
    SUM(
      CASE WHEN a.article_when + 90*86400 >= 0+strftime('%s', 'now')
        THEN e.enclosure_time
        ELSE 0
      END)/(90*3600) AS "2160h",
    CASE WHEN f.feed_enabled = 1 THEN
      SUM(
        e.enclosure_time
      )/((
        MAX(a.article_when)-MIN(a.article_when)
      )/24)
    ELSE 0
    END AS "4ever"
  FROM
    feeds f
    LEFT JOIN articles a ON (f.feed_no = a.feed_no AND a.article_use = 1)
    LEFT JOIN articles_enclosures ae ON (a.article_no = ae.article_no)
    LEFT JOIN enclosures e ON (
      ae.enclosure_no = e.enclosure_no AND e.enclosure_use = 1
    )
  GROUP BY f.feed_no
  HAVING
    f.feed_enabled = 1
    OR "48h" > 0
    OR "168h" > 0
    OR "720h" > 0
    OR "2160h" > 0
  ORDER BY
    f.feed_enabled DESC, "4ever" DESC
QUERY
	$sth->execute;
	my @total = (0)x($sth->{NUM_OF_FIELDS}-2);
	while (my (undef, $n, @times) = $sth->fetchrow_array) {
		pairwise { our ($a, $b); $a += ($b // 0) } @total, @times;
		$tab->addRow($n, map format_perday($_), @times);
	}
	$tab->addRowLine;
	$tab->addRow('TOTAL', map format_perday($_), @total);
	$tab->addRow('', map sprintf("%im", $_*60), @total);
	print $tab;
}

sub list {
	my $go = Getopt::Long::Parser->new(
		config => [qw( gnu_compat require_order )]);

	my %opts;
	$go->getoptions(\%opts, qw(feeds|f) ) or pod2usage(2);
	keys %opts or pod2usage("Need to specify something to list.");
	
	if ($opts{feeds}) {
		my $tab = Text::ASCIITable->new({
				outputWidth => 72,
				headingText => 'Feeds'
		});
		$tab->setCols('Enabled', 'Feed Name', 'Feed #');
		$tab->addRow(@$_) foreach @{$DB->selectall_arrayref(<<QUERY)};
SELECT
	CASE WHEN feed_enabled THEN 'Yes' ELSE 'No' END, 
    feed_name,
	feed_no
  FROM feeds
  ORDER BY feed_enabled DESC, feed_name ASC
QUERY
		say $tab;
	}
}

sub format_perday {
	defined $_[0]
		or return 'N/A';
	my $r = sprintf('%04.2f', $_[0]);
	'0.00' eq $r ? $_[0] == 0 ? '' : 'T' : $r;
}

sub find_file {
	my ($name, $playlist_no) = @_;
	my $d_pending = CONFIG->{storage}{pendingmedia};
	my $d_plist = CONFIG->{storage}{playlistedmedia};
	my $full_name;
	if (defined $playlist_no) {
		$full_name = (-e "$d_plist/$playlist_no/$name")
			? "$d_plist/$playlist_no/$name"
			: "$d_plist/$name";
	} else {
		$full_name = "$d_pending/$name";
	}

	return (-e $full_name) ? $full_name : undef;
}

sub cleanup {
	# TODO: enclosure table really ought to explicitly store where the
	#       file is currently located: pending, unusable, playlist.
	
	hasherize(); # make sure we have the hash before moving the file

	my $sth = $DB->prepare(<<QUERY);
SELECT enclosure_file
  FROM enclosures
  WHERE
    enclosure_use = 0
    AND playlist_no IS NULL
    AND enclosure_file IS NOT NULL
QUERY

 	TRACE("Finding enclosure_use=0 media in db");
 	$sth->execute;

	INFO("Moving unusable files, this may take a while");
 	my $moved = 0;
 	while (my ($file) = $sth->fetchrow_array) {
		my $path = notaint(find_file($file, undef));
		defined $path or next; # assume already moved
		my $new = notaint(CONFIG->{storage}{unusablemedia} . "/$file");
		-e $new
			and LOGDIE("WTF — $new already exists");
		
		TRACE("Moving $file");
		move $path, $new
			or LOGDIE("rename($path, $new) failed: $!");
		++$moved;
	}

	INFO("Moved $moved files to UnusableMedia");

	INFO("Vacuuming database");
	$DB->vacuum();
	INFO("Database vacuumed.");
}

sub hasherize {
	my $sth = $DB->prepare(<<QUERY);
SELECT enclosure_no, enclosure_file, playlist_no
  FROM enclosures
  WHERE
    enclosure_file IS NOT NULL
    AND enclosure_hash IS NULL
QUERY

	my $upd = $DB->prepare(<<QUERY);
UPDATE enclosures
  SET enclosure_hash = ?
  WHERE enclosure_no = ?
QUERY

	TRACE("Finding media without hash in db");
	$sth->execute;

	my $ctx = Digest->new('SHA-256')
		or LOGDIE("Couldn't get SHA-256 digest");
	while (my ($enc_no, $enc_file, $enc_plist) = $sth->fetchrow_array) {
		my $file = find_file($enc_file, $enc_plist);
		unless (defined $file) {
			WARN("Couldn't find file for #$enc_no ($enc_file)");
			next;
		}

		$ctx->reset;
		if (open my $fh, '<:raw', $file) {
			$ctx->addfile($fh);
			close $fh or LOGDIE("Close on $file failed: $!");
		} else {
			ERROR("Could not open $file: $!");
			next;
		}
		my $hash = 'sha256:' . $ctx->b64digest;

		TRACE("$enc_file: $hash");
		$upd->execute($hash, $enc_no);
	}
}

sub originalize {
	TRACE("Marking duplicates as don't use.");
	my $dups = $DB->selectall_arrayref(<<QUERY);
SELECT DISTINCT
    e2.enclosure_no, e2.enclosure_file
  FROM
    enclosures e1 JOIN enclosures e2 ON (
      e1.enclosure_hash = e2.enclosure_hash
    )
  WHERE
    e1.enclosure_no < e2.enclosure_no 
    AND e1.enclosure_use = 1 AND e2.enclosure_use = 1
    AND e2.playlist_no IS NULL
QUERY
	
	my $mark = $DB->prepare(<<QUERY);
UPDATE enclosures SET enclosure_use = 0 WHERE enclosure_no = ?
QUERY
	foreach my $dup (@$dups) {
		INFO("Duplicate: $dup->[1]; setting enclosure_use=0");
		$mark->execute($dup->[0]);
	}
}

sub stopwatch {
	my $sth = $DB->prepare(<<QUERY);
SELECT enclosure_no, enclosure_file
  FROM enclosures
  WHERE
    enclosure_file IS NOT NULL
    AND enclosure_time IS NULL
    AND enclosure_use = 1
QUERY

	my $upd = $DB->prepare(<<QUERY);
UPDATE enclosures
  SET enclosure_time = ?
  WHERE enclosure_no = ?
QUERY

	TRACE("Finding media without length in db");
	$sth->execute;

	my $dir = CONFIG->{storage}{pendingmedia};
	while (my ($enc_no, $enc_file) = $sth->fetchrow_array) {
		my $file = notaint("$dir/$enc_file");
		my $len;

		unless ($enc_file =~ /\.(.{3})$/) {
			ERROR("Could not find suffix in $enc_file");
			ERROR("This shouldn't happen, as wel always set a suffix. WTF.");
			next;
		}
		if ($1 eq 'mp3') {
			my $inf = get_mp3info($file);
			if ($inf) {
				$len = $inf->{SECS};
			} else {
				WARN("Could not get length of $file");
			}
		} elsif ($1 eq 'ogg') {
			my $ogg = Ogg::Vorbis::Header::PurePerl->new($file);
			if ($ogg) {
				$len = $ogg->info('length');
			} else {
				WARN("Ogg parser doesn't think $file is ogg");
			}
		}
		else {
			ERROR("Don't know how to get length of $1 files");
		}

		defined $len && 0 == $len
			and WARN("Got length of 0 for $file; probably wrong!");

		DEBUG("$enc_file: " . (defined $len ? $len : 'undef'));
		$upd->execute($len, $enc_no);
	}
}

sub playlist {
	$DB->do('INSERT INTO playlists(playlist_ctime) VALUES (?)', {}, time());

	my $p_no = $DB->last_insert_id('', '', 'playlists', 'playlist_no')
		or LOGDIE("Could not get playlist number");

	my $plist_dir = get_playlist_mediapath(playlist => $p_no);
	-d $plist_dir
		or mkpath $plist_dir
		or LOGDIE("Could not create playlist media directory $plist_dir: $!");
	TRACE("Using playlist dir $plist_dir");

	my @randoms = find_random_items();
	my @playlist = ();
	my @bans;
	my $duration = 0;
	my $last_feed = 0; # feed_no's start at 1, avoid undef warnings
	my $consec = 0;
	my %feed_cnts;;
	my $since_rand_itms = 0;
	my $since_rand_time = 0;
	my $random_m = CONFIG->{playlist}{randomchancem};
	my $random_b = CONFIG->{playlist}{randomchanceb};
	my $random_mode = lc(CONFIG->{playlist}{randomchancemode});

	if (CONFIG->{playlist}{announcebegin}) {
		push @playlist, announce(begin => $plist_dir, {
			current => $p_no,
			next => 1+$p_no,
		});
	}

	my $mark = $DB->prepare(<<QUERY);
UPDATE enclosures
  SET playlist_no = ?, playlist_so = ?
  WHERE enclosure_no = ?
QUERY

	until ($duration >= CONFIG->{playlist}{targetduration}
			|| @playlist >= CONFIG->{playlist}{maximumfiles})
	{
		my $only_feed = '1';
		my $order;
		my $where = playlist_valid_where(scalar @playlist,
			$duration, $last_feed, $consec, \@bans);
		TRACE("Rules-enforcing WHERE: $where");

		# Figure the choice method
		if (CONFIG->{playlist}{choicemethod} =~ /RandomFeed/i) {
			($only_feed) = $DB->selectrow_array(<<QUERY);
SELECT DISTINCT feed_no FROM valids
  WHERE $where
  ORDER BY random() LIMIT 1
QUERY
			$order = 'random()';
			$only_feed
				or last;
			TRACE("Picked feed $only_feed");
			$only_feed = "feed_no = $only_feed";
		} else {
			my $method = lc(CONFIG->{playlist}{choicemethod});
			if    ($method eq 'random')  { $order = 'random()' }
			elsif ($method eq 'longest') { $order = 'enclosure_time DESC' }
			elsif ($method eq 'oldest')  { $order = 'enclosure_when ASC' }
			else                         { LOGIDE("Unknown ChoiceMethod: $_") }
		}
		TRACE("ORDER BY $order");

		# Chose an item.
		my ($feed_no, $enc_no, $enc_file, $enc_time)
			= $DB->selectrow_array(<<QUERY);
SELECT feed_no, enclosure_no, enclosure_file, enclosure_time
  FROM valids
  WHERE ($where) AND ($only_feed)
  ORDER BY $order
  LIMIT 1
QUERY
		$enc_no
			or last;
		DEBUG("Picked feed $feed_no, enc $enc_no, dur $enc_time");

		push @playlist, $enc_file;
		$duration += $enc_time;

		if ($feed_no == $last_feed) {
			++$consec;
		} else {
			$last_feed = $feed_no;
			$consec = 1;
		}

		if (++$feed_cnts{$feed_no} >= CONFIG->{playlist}{maximumperfeed}) {
			push @bans, $feed_no;
		}

		$mark->execute($p_no, scalar(@playlist), $enc_no);

		# Update random stats
		++$since_rand_itms;
		$since_rand_time += $enc_time;

		# Randomly add a random item, maybe.
		my $add_random = 0;
		my $x
			= ('time' eq $random_mode) ? $since_rand_time : $since_rand_itms;
		my $chance = $x * $random_m + $random_b;
		TRACE("Random chance = $chance");
		if (rand() < $chance) {
			my $item = get_one_random(\@randoms, $mark, $p_no, 1+@playlist);
			DEBUG("Adding random item $item");
			push @playlist, $item;

			$since_rand_time = 0;
			$since_rand_itms = 0;

			if (CONFIG->{playlist}{resetconsecutive}) {
				$consec = 0;
				$last_feed = 0;
			}
		}


		DEBUG("Playlist files=" . scalar(@playlist) . "; dur=$duration");
	}

	TRACE("Done with playlist add loop - doing constraint checks");
	$duration < CONFIG->{playlist}{minimumduration}
		and LOGDIE("Playlist too short; abort");
	@playlist < CONFIG->{playlist}{minimumfiles}
		and LOGDIE("Playlist has too few files; abort");

	if ((my $ll = CONFIG->{playlist}{leadoutlength}) > 0) {
		if (CONFIG->{playlist}{announceleadout}) {
			push @playlist, announce(leadout => $plist_dir, {
				current => $p_no,
				next => 1+$p_no,
			});
		}

		for (1..$ll) {
			my $item = get_one_random(\@randoms);
			DEBUG("Adding leadout item $item");
			push @playlist, $item;
		}
	}

	if (CONFIG->{playlist}{announceend}) {
		push @playlist, announce(end => $plist_dir, {
			current => $p_no,
			next => 1+$p_no,
		});
	}

	my $fname = get_playlist_path(playlist => $p_no);
	DEBUG("Writing playlist $fname");
	write_file($fname, map $_ =~ m!^/! ? "$_\n" : "$plist_dir/$_\n", @playlist);
	TRACE("Moving files");
	foreach my $f (@playlist) {
		next if $f =~ m!^/!; # prob random item
		my $old = notaint(CONFIG->{storage}{pendingmedia}."/$f");
		my $new = notaint("$plist_dir/$f");
		
		-e $new
			and LOGDIE("WTF - $new already exists");

		rename($old, $new)
			or LOGDIE("could not rename $old to $new");
	}
}

sub get_playlist_path {
	my %opts = @_;
	$opts{playlist} // LOGDIE("get_playlist_path called w/o playlist");
	$opts{archived} //= 0;

	my $storage = $opts{archived}
		? CONFIG->{storage}{archivedplaylists}
		: CONFIG->{storage}{playlists};

	return notaint(
		sprintf("%s/Playlist %03i.m3u", $storage, $opts{playlist}));
}

sub get_playlist_mediapath {
	my %opts = @_;
	$opts{playlist} // LOGDIE("get_playlist_mediapath called w/o playlist");
	$opts{archived} //= 0;

	my $storage = $opts{archived}
		? CONFIG->{storage}{archivedmedia}
		: CONFIG->{storage}{playlistedmedia};

	return notaint("$storage/$opts{playlist}");
}

sub find_mediafile {
	my %opts = @_;

	$opts{playlist} // LOGDIE("TODO: find_mediafile for non-playlisted");
	$opts{archived} //= 0;
	$opts{file} // LOGDIE("find_mediafile not given file name");

	get_playlist_mediapath(%opts) . '/' . $opts{file};
}

sub get_one_random {
	my ($randoms, $mark, $p_no, $p_pos) = @_;
	my $rmedia = $randoms->[int rand @$randoms];

	return $rmedia if rand() >= CONFIG->{playlist}{randomfeedratio};
	return $rmedia unless defined $mark;
	return $rmedia
		unless my ($enc_no, $enc_file) = $DB->selectrow_array(<<QUERY);
SELECT enclosure_no, enclosure_file
  FROM valids
  WHERE feed_is_music = 1
  ORDER BY random()
  LIMIT 1
QUERY
	$mark->execute($p_no, $p_pos, $enc_no);
	return $enc_file;
}

sub announce {
	my ($event, $dir, $subs) = @_;

	$event = lc $event;
	exists CONFIG->{speech}{message}{$event}
		or LOGDIE("Tried to announce unconfigured message $event");

	my $msg = CONFIG->{speech}{message}{$event};
	TRACE("Message for $event: $msg; doing subs");

	$msg =~ s/__(.+?)__/$subs->{lc $1}/ge;

	return speak($msg => $dir);
}

sub speak {
	my ($what, $dir) = @_;

	my (undef, $tmp_wav) = tempfile('speech.XXXXXX', DIR => notaint($dir), SUFFIX => '.wav');

	TRACE("Speaking $what");

	CONFIG->{speech}{engine} =~ /^festival$/i
		or LOGDIE("Festival is the only supported TTS engine, sorry.");

	my $voice = CONFIG->{speech}{voice};
	$voice =~ /^\(?(?:voice_)?([a-z_]+)\)?$/
		or LOGDIE("Invalid voice syntax: $voice");
	$voice = "(voice_$voice)";

	my $dBFS = CONFIG->{speech}{volume};
	$dBFS =~ /^-?(\d+)(?:dbfs)?$/i
		or LOGDIE("Invalid volume: $dBFS");
	$dBFS = "-${1}dBFS";

	TRACE("Invoking festival w/ voice $voice");
	run3 [qw(text2wave -eval), $voice, qw(-f 44100 -o), $tmp_wav], \$what
		or LOGDIE("text2wave failed: $! $?");

	TRACE("Normalizing output to $dBFS");
	run3 [qw(normalize-audio -q -a), $dBFS, $tmp_wav]
		or LOGDIE("normalize-audio failed: $! $?");

	my $format = CONFIG->{speech}{format};
	if ($format eq 'wav') {
		return $tmp_wav
	} elsif ($format eq 'mp3') {
		my (undef, $tmp_mp3) = tempfile('speech.XXXXXX', DIR => notaint($dir), SUFFIX => '.mp3');
		TRACE("Encoding mp3");
		run3 [qw(lame --quiet --preset medium), $tmp_wav, $tmp_mp3]
			or LOGDIE("lame failed: $! $?");
		unlink $tmp_wav;
		return $tmp_mp3;
	} elsif ($format eq 'ogg') {
		my (undef, $tmp_ogg) = tempfile('speech.XXXXXX', DIR => notaint($dir), SUFFIX => '.ogg');
		TRACE("Encoding ogg");
		run3 [qw(oggenc -Q -q0 -o), $tmp_ogg, $tmp_wav]
			or LOGDIE("oggenc failed: $! $?");
		unlink $tmp_wav;
		return $tmp_ogg;
	} else {
		LOGDIE("Uknown format $_")
	}

	LOGDIE("Unreachable code reached");
}

sub all_playlists {
	while (1) {
		playlist();
		$DB->commit;
	}
}

sub playlist_valid_where {
	my ($cur_files, $cur_time, $last_feed, $consec, $bans) = @_;

	my $not_in;
	if ($consec >= CONFIG->{playlist}{maximumconsecutive}) {
		$not_in = join(q{,}, $last_feed, @$bans);
	} else {
		$not_in = join(q{,}, @$bans);
	}
	$not_in = ('' ne $not_in) ? "feed_no NOT IN ($not_in)" : '1';

	my $time_constraint = 1;
	if ($cur_files >= CONFIG->{playlist}{minimumfiles}) {
		my $mx = CONFIG->{playlist}{maximumduration} - $cur_time;
		$time_constraint = "enclosure_time <= $mx";
	};

	return "$not_in AND $time_constraint AND feed_is_music = 0";
}

sub find_random_items {
	my @files;

	find({
			wanted => sub {
				-f -r $File::Find::fullname
					and push @files, $File::Find::fullname;
			},
			follow  => 1,
			untaint => 1,
		},
		notaint(CONFIG->{storage}{randommedia}));

	return @files;
}

sub archive {
	if (0 == @ARGV) {
		ERROR("No playlists specified to archive. Try --help");
		return;
	}

	foreach my $arg (@ARGV) {
		my $p_no;
		if ($arg =~ /^[0-9]+$/) {
			$p_no = 0 + $arg;
		} elsif ($arg =~ /^Playlist ([0-9]+)\.m3u$/) {
			$p_no = 0 + $1;
		} else {
			ERROR("Invalid playlist argument: '$arg'. Stopping!");
			return;
		}

		my $m3u_src = get_playlist_path(playlist => $p_no, archived => 0);
		my $m3u_dst = get_playlist_path(playlist => $p_no, archived => 1);
		my $media_src = get_playlist_mediapath(playlist => $p_no, archived => 0);
		my $media_dst = get_playlist_mediapath(playlist => $p_no, archived => 1);

		# check dest first, to give a better error message (already
		# archived)
		-f $m3u_dst
			and LOGDIE("Archived playlist $m3u_dst already exists!");
		-f $m3u_src
			or LOGDIE("Playlist $m3u_src does not exist");
		-d $media_dst
			and LOGDIE("Archived media $media_dst already exists!");
		-d $media_src
			or LOGDIE("Media directory $media_src does not exist");

		# DB first since it can roll back
		$DB->archive_playlist($p_no);

		# then move
		TRACE("Moving $m3u_src -> $m3u_dst");
		move($m3u_src, $m3u_dst) or LOGDIE("move $m3u_src -> $m3u_dst: $!");
		TRACE("Moving $media_src -> $media_dst");
		move($media_src, $media_dst)
			or LOGDIE("move $media_src -> $media_dst: $!");

		# we commit after each archival, because a rollback wouldn't move
		# the files back.
		$DB->commit;
		INFO("Archived playlist $p_no");
	}
}

sub feed {
	# TODO: Somehow get the random between-podcast items, but not of
	#       course the leadout.
	my $feed = XML::FeedPP::RSS->new(
		title       => 'Podist RSS Export',
		link        => 'https://github.com/derobert/Podist',
		description => q{RSS export of current playlists in Podist},
		generator   => 'Podist',
		pubDate     => time(),
	);

	foreach my $enc (@{ $DB->unarchived_playlist_info }) {
		my $title = sprintf('[%03i-%02i] %s (%s)',
			$enc->{playlist_no}, $enc->{playlist_so},
			($enc->{article_title} // $enc->{enclosure_file}),
			$enc->{feed_name});
		my @item_extra;
		if (CONFIG->{feed}{fudgedates}) {
			@item_extra = (
				pubDate     => $enc->{playlist_no} * 1000 + $enc->{playlist_so},
				description => q{From }
					. strftime('%F %H:%M:%S %Z', localtime $enc->{article_when}) . q{.}
			);
		} else {
			@item_extra = (pubDate => $enc->{article_when});
		}
		my $item = $feed->add_item(title => $title, @item_extra);
		$item->guid("podist-" . $DB->uuid . '-enclosure-' . $enc->{enclosure_no}, 'false');
		my $mime;
		$enc->{enclosure_file} =~ /\.(\S{3})$/
			and $mime = $MIME_MAP{lc $1};
		my $file = find_mediafile(
			playlist => $enc->{playlist_no},
			archived => defined $enc->{playlist_archived},
			file => $enc->{enclosure_file},
		);
		my $size = -s $file;
		$item->set('source@url', $enc->{feed_url});
		$item->set('enclosure@url', CONFIG->{feed}{baseurl} . File::Spec->abs2rel($file, CONFIG->{storage}{playlists}));
		$item->set('enclosure@length', $size);
		$item->set('enclosure@type', $mime) if defined $mime;
	}

	write_file(CONFIG->{storage}{playlists} . '/feed.xml', $feed->to_string);
	INFO("Exported feed");
}

sub notaint {
	defined $_[0] or return undef;
	$_[0] =~ /^(.+)$/s;
	$1;
}

sub parse_global_opts {
	my ($help, $man, $confdir);
	my $getopt = Getopt::Long::Parser->new(
		config => [qw( gnu_compat require_order bundling)]);
	$getopt->getoptions(
		'help|?'               => \$help,
		'man|manual'           => \$man,
		'conf-dir|confdir|c=s' => \$confdir
	) or pod2usage(2);

	if ($help) {
		pod2usage(
			-exitval => 0,
			-verbose => 99,
			-sections => [ 'SYNOPSIS', 'GLOBAL OPTIONS', 'COMMAND SUMMARY' ],
			-output => \*STDOUT,
		);
	}

	if ($man) {
		pod2usage(
			-exitval => 0,
			-verbose => 2,
			-output => \*STDOUT,
		);
		exit 0;
	}

	return { config_dir => $confdir };
}

sub setup {
	my $confdir = shift // notaint("$ENV{HOME}/.podist");

	-d $confdir
		or mkdir $confdir
		or die "Could not mkdir $confdir: $!";

	# read config and install sub
	my $config = setup_config($confdir);
	*CONFIG = sub() { $config };

	init_logging();

	if (CONFIG->{notyetconfigured}) {
		FATAL(<<ERR);
Podist has not been configured. Please review this configuration file
and set NotYetConfigured to false:
    $confdir/podist.conf
ERR
		exit 1;
	}

	# Untaint the environment
	$ENV{PATH} = notaint($ENV{PATH});

	# Setup our output directories.
	setup_dirs();

	# setup the DB
	$DB = Podist::Database->new(
		dsn => CONFIG->{database}{dsn},
		username => CONFIG->{database}{username},
		password => CONFIG->{database}{password}
	);

	return;
}

sub setup_dirs {

	for my $d (
		@{CONFIG->{storage}}{
			qw(pendingmedia playlistedmedia
				playlists randommedia)
		})
	{
		-d $d
			or mkpath(notaint($d))
			or LOGDIE("Could not mkpath($d): $!");
	}
}

sub init_logging {
	if (CONFIG->{logging}{simple}) {
		my $level = uc(CONFIG->{logging}{level});
		Log::Log4perl->init(\<<L4P);
log4perl.category = $level, Screen
log4perl.appender.Screen = Log::Log4perl::Appender::ScreenColoredLevels
log4perl.appender.Screen.layout = Log::Log4perl::Layout::PatternLayout::Multiline
log4perl.appender.Screen.layout.ConversionPattern = [%r] %m%n
L4P
	} else {
		Log::Log4perl::init(CONFIG->{logging}{config});
	}
	TRACE("Log4perl configured and hopefully ready.");
}

sub setup_config {
	my ($confdir) = @_;
	my $conffile = "$confdir/podist.conf";

	my $default_config = <<CONF;
# Once you've reviewed this file, change this to false.
NotYetConfigured true
DataDir $confdir # e.g., \$HOME/.podist

<storage>
	PendingMedia      \$HOME/Podist/media-pending
	UnusableMedia     \$HOME/Podist/media-unusable
	PlaylistedMedia   \$HOME/Podist/media-listed
	Playlists         \$HOME/Podist/playlists
	ArchivedPlaylists \$HOME/Podist/archived/playlist
	ArchivedMedia     \$HOME/Podist/archived/media
	RandomMedia       \$HOME/Podist/playlists/random
</storage>

<feed>
    BaseURL      http://yourserver/podist/
    FudgeDates   no
</feed>

<article>
	# Note this is after basic title whitespace normalization.
	TitleIgnoreRE   "(?i:[\[(]rebroadcast[\])])$"
</article>

<playlist>
	# These are constraints for playlist generation. They are followed
	# as:
	#   1. If there are less than MinimumFiles, add any valid file (defined
	#      below)
	#   2. If there are MaximumFiles, stop. This playlist is done.
	#   3. If the playlist duration is less than TargetDuration, add any
	#      valid file such that the duration does not exceed
	#      MaximumDuration. If there are no files to add, stop, this
	#      playlist is done.
	#   4. If the playlist duration is at least TargetDuration, stop.
	#      This playlist is done.
	# Those are repeated until hitting a "stop", of course.
	#
	# As a final check, before comitting the playlist, if the total
	# length is less than MinimumDuration, abort.
	#
	# A valid file is any file that is:
	#   - the oldest unplaylisted file in its feed, if the feed is ordered
	#   - any unplaylisted file in an unordered feed
	# and does not put more than MaxConsecutive files from the same feed
	# in a row and does not exceed MaximumPerFeed files from that feed
	# in the current playlist.
	MinimumDuration    1800
	TargetDuration     3600
	MaximumDuration    7200
	MinimumFiles       1
	MaximumFiles       5
	MaximumConsecutive 2
	MaximumPerFeed     4

	# How do we pick between multiple valid options, all of which follow
	# the rules?
	#   - Random: pick completely at random
	#   - RandomFeed: pick at random, but make sure each feed has an
	#                 equal chance even if feed A has 10 eps, and feed B
	#                 has 300.
	#   - Longest: Pick the longest (duration) 
	#   - Oldest: Pick the oldest
	ChoiceMethod       RandomFeed
	
	# What should the chance be of throwing in a random item after each
	# played item?
	#   - Mode: Count, Time
	#   - M: Slope
	#   - B: Y-intercept, aka constan in constant func
	# That is, f(x) = mx + b
	#
	# NOTE: Random items are ignored in length/duration constraints
	#       (above).
	RandomChanceMode   Time
	RandomChanceM      1/7200
	RandomChanceB      0.2
	
	# How often should we use \$RandomMedia vs. feeds marked as music in
	# the database? 0 is always \$RandomMedia, 1 is always music feeds.
	# Note that if there aren't any unplayed items in music feeds, will
	# fall back to \$RandomMedia. (Note: music feeds always use
	# ChoiceMethod random)
	RandomFeedRatio    1/3

	# If we insert a random item, does this reset the consecutive same
	# podcast counter?
	ResetConsecutive   yes

	# Specify how many random items to play after the end of podcasts on
	# a playlist (so you don't have to switch while driving)
	LeadoutLength 5

	# Shall we put an announcement at the beginning and/or end of the
	# playlists we generate using a TTS (see the speech section below)
	AnnounceBegin Yes
	AnnounceLeadout Yes
	AnnounceEnd   Yes
</playlist>

<speech>
	# Which TTS engine shall we use? Currently, only Festival is
	# supported.
	Engine Festival

	# The voice to use
	Voice rab_diphone

	# How loud to make the audio
	Volume 12dbFS

	# Which format to get the audio in enventually. Options are:
	#   wav, mp3, ogg (listed largest -> smallest)
	Format ogg

	# What to say
	<message>
		Begin   Start of playlist __CURRENT__.
		Leadout End of podcasts in playlist __CURRENT__.
		End     End of playlist __CURRENT__.
	</message>
</speech>

<database>
	DSN dbi:SQLite:dbname=\$DataDir/podist.db
	Username   # fill in if DB requires
	Password   # fill in if DB requires
</database>

<logging>
	Simple true
	Level info   # fatal | error | warn | info | debug | trace

	### Alternatively, for more control,
	# Simple false
	# Config \$DataDir/log4perl.conf
</logging>
CONF

	-e $conffile
		or write_file($conffile, \$default_config);

	# Don't repeat yourself.
	#
	# Unfortunately, we need the string representation of the config (so
	# we can have comments in it), hopefully this isn't too slow...
	my %parse_opts_common = (
		-AllowMultiOptions    => 0,
		-LowerCaseNames       => 1,
		-UseApacheInclude     => 1,
		-IncludeRelative      => 1,
		-IncludeDirectories   => 1,
		-IncludeGlob          => 1,
		-IncludeAgain         => 1,
		-MergeDuplicateBlocks => 1,
		-AutoLaunder           => 1,
		-AutoTrue              => 1,
		-InterPolateVars       => 1,
		-InterPolateEnv        => 1,
		-StrictVars            => 1,
		-SplitPolicy           => 'whitespace',

	);
	my $cg_def = new Config::General(
		-String               => $default_config,
		%parse_opts_common,
	);
	my %defs = $cg_def->getall;

	# Yes, in the first-use case, this will be the exact same as the
	# defaults, but oh well.
	my $cg_conf = new Config::General(
		-ConfigFile            => $conffile,
		-MergeDuplicateOptions => 1,
		-DefaultConfig         => \%defs,
		%parse_opts_common,
	);

	my $config = { $cg_conf->getall };

	# durations can have H or M after them; normalize to seconds. If
	# someone explicitly specified S for seconds, that's fine too...
	foreach my $v (qw(minimumduration targetduration maximumduration)) {
		$config->{playlist}{$v} =~ /^(\d+)\s*S$/i
			and $config->{playlist}{$v} = $1;
		$config->{playlist}{$v} =~ /^(\d+)\s*M$/i
			and $config->{playlist}{$v} = $1 * 60;
		$config->{playlist}{$v} =~ /^(\d+)\s*H$/i
			and $config->{playlist}{$v} = $1 * 3600;
	}

	# change fractions for to decimals
	foreach my $v (qw(randomchancem randomchanceb randomfeedratio)) {
		$config->{playlist}{$v} =~ m!(\d+)/(\d+)!
			and $config->{playlist}{$v} = $1/$2;
	}

	# compile TitleIgnoreRE regex.
	eval {
		$config->{article}{titleignorere}
			= qr/$config->{article}{titleignorere}/;
	};
	if ($@) {
		# can't use ERROR yet. Log4perl isn't set up.
		(my $err = $@) =~ s/ at \S+ line \d+\.\n$//;
		print STDERR <<ERR;
Invalid configuration file found. Expected a valid regular expression
for the TitleIgnoreRE option in the <article> block. Attempting to
compile:

   $config->{article}{titleignorere}

gave the following Perl error:

   $err

Exiting.
ERR
		exit 1;
	}


	return $config;
}


sub USER_AGENT() {
	state $agent;
	unless ($agent) {
		$agent = LWP::UserAgent->new(
			agent => 'Podist/0.3', # space at end: append _agent
			env_proxy => 1,
			keep_alive => 4, # Some podcasts love redirects
			cookie_jar => { }, # temp only
		);

		$agent->default_header(
			Accept => 'application/rss+xml, application/atom+xml, audio/ogg, audio/x-ogg, audio/mpeg, application/rdf+xml;q=0.9, application/xml;q=0.8, text/xml;q=0.8, application/ogg;q=0.8, audio/*;q=0.7, */*;q=0.1'
		);
	}

	return $agent;
}

__END__

=encoding utf8

=head1 NAME

Podist - A podcatcher

=head1 SYNOPSIS

podist [I<global-options>] I<command> [I<command-options>] [I<arguments>]

podist --help

podist --manual

=head1 COMMAND SUMMARY

B<catch> — Find & download new episodes.

B<subscribe> I<name> I<url> — Subcribe to a new feed at I<url> and call
it I<name>.

B<playlist> — Generate a playlist.

B<status> — Show unplayed counts & other statistics.

=head1 GLOBAL OPTIONS

=over

=item B<--conf-dir>

Directory to store the configuration file in. Also the default place to
store the SQLite database.

=item B<--help>

Displays help.

=item B<--man>

Displays the manual page.

=back

=head1 COMMANDS IN DETAIL

=head2 B<subscribe> | B<new> | B<add> I<name> I<URL>

Subscribe to a new podcast named Name with feed at URL. URL should be
the RSS or Atom feed. Name is anything you want, but must be unique for
all your subscribed podcasts. Remember to quote Name and URL for your
shell.

=over

=item I<name>

What to call this podcast. Used in messages, status output, etc. Any
string you'd like.

=item I<URL>

URL of the feed. All common formats are accepted (Atom and multiple
versions of RSS).

=back

=head2 B<catch>

Run the podcatcher. The same as fetch, download, and stopwatch (in that
order) below.

=head2 B<fetch> [ --feeds I<feed_no> ... ] [ --limit I<N> ]

Grabs the subscribed RSS feeds and adds all the enclosures to the
database. Does not actually download the enclosures.

=over

=item B<--feeds> | B<-f> I<feed_number> ...

One of more feeds to fetch. This overrides the default of fetching all
enabled feeds. Note that with this, you can even fetch disabled feeds.

Note that feeds are specified by their feed number, which can be
discovered using the L<C<list --feeds>|/"list"> command.

=item B<--fetch-limit> | B<--new-limit> | B<--limit> | S<B<-l> I<N>>

Override the database-set limit of new items to grab from the feed. This
is useful when something special happens on a feed and you actually do
want to grab those 20 new episodes that were posted.

=back

=head2 B<download>

Downloads enclosures that are in the database (from fetch) but not
yet downloaded.

=head2 B<hash>

Calculates the hash for each downloaded podcast and stores this in
the database. The hash is used to catch duplicates.

=head2 B<originalize>

Finds duplicate podcasts based on their hash, and marks the second
(and third, etc.) copies such that they won't be used.

=head2 B<stopwatch>

Calculates how long each downloaded podcast is, and stores this
information in the database.

=head2 B<playlist>

Builds playlists based on downloaded, stopwatched media in the
database.

=head2 B<archive> Plalist-1 ...

Archives the given playlists. Playlists may be specified either as file
names ("Playlist 625.m3u") or as plain numbers ("625"). At least one
playlist must be specified.

Archiving a playlist means that the files are moved to the archived
playlists directory and the playlist is marked as archived in the
database.

Currently, the only effect on Podist operation is that archived
playlists are not included in the generated feed (feed.xml in the
playlist directory).

=head2 B<feed>

Generates an RSS feed from the non-archived playlists. The feed will be
in the same order as the playlists (so consuming podcatchers should be
instructed to use it in order).

=head2 B<status>

Shows a summary of what's in the database.

=head2 B<list> I<options>

Shows various things from the database.

=over

=item B<--feeds> | B<-f>

List the feeds in the database, both enabled and disabled.

=back

=head2 B<cleanup>

Do various once-in-a-while cleanup tasks, like moving enclosures
that we're not going to use (duplicates, manually set to not use
in database, etc.) to the unusable folder.
